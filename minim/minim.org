#+title: Minim Manual (river/context elision/yumi/minim)
#+STARTUP: hidestars
#+TAGS: noexport(e)
#+EXPORT_EXCLUDE_TAGS: noexport
#+SETUPFILE: org-mode.conf
#+OPTIONS: H:10 author:Alexis Read

* Getting Started

** What Is minim

Minim is a self-verified language-based operating system. To be able to be self-verified, 
it needs to be as small as possible, while retaining enough features to be able to do formal verification on itself.
At heart, Minim is a practical system designed to run well on microcontrollers, and so features OS facilities for doing that.
Hopefully minim will get closer to solving the hard problems in computing: trust, and ordering.

** Why a new language? - Features

Minim (aims) for the following features:
- Completely self-verified starting with hex code construction
- Managed memory without GC - deterministic for hard realtime systems. This makes use of concat, components, ASAP/PRC, mainly immutable
- Small enough to run in embedded systems
- Unique syntax for concatenative *and* conventional usage
- AOT with a runtime library, to allow for a REPL
- Strong dynamic typing, namespaces, modules, components via contexts
- Multithreaded and multiprocess capable through delimited continuations
- Logic sublanguage able to handle CoC, relational/equational reasoning, reactive computation and TVL
- macro system
- homoiconic
- capability based
- cycle, church-rosser and other proof checkers, built-in unit testing and mocking
- distributed aka shared mutable state via mapLattices (KV store) and delimited continuations
- effect types and handlers, which can compile down to lambdas
- configuration sublanguage which can be serialised - this is a non-turing complete version of the main language
- extremely literate programming using scoped comments, metadata, unit tests and name hashes in org-mode
- open composition/vau ie. new special forms can be defined
- temporal syntax via dedalus

** Where's the code?

The above is a large list to try to implement, so the code is a work in progress!
Minim is literately programmed in a similar fashion to [[https://github.com/nakkaya/ferret/blob/master/ferret.org][fennel]] ie. this document contains the code, which can be (un)tangled to be compiled,
so please consider this document as both a manifesto, and a repo for the code.

*** Requirements:
For the moment, linux, emacs, clang (maru.10), gcc (Minim folder), make.
On debian-based systems you can do:
apt install build-essential emacs

*** Building the code:
http://fgiasson.com/blog/index.php/2016/10/26/literate-clojure-programming-tangle-all-in-org-mode/
To (un)tangle the code from the document just type 'make tangle' from the Minim folder



** Recommended Reading

*** To understand https://www.piumarta.com/software/maru/#2:
https://www.piumarta.com/software/cola/colas-whitepaper.pdf
https://www.piumarta.com/freeco11/freeco11-piumarta-oecm.pdf
https://github.com/attila-lendvai/maru/blob/maru.10/doc/

*** To understand https://github.com/manuel/wat-js:
http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf
http://www.cs.indiana.edu/~dyb/pubs/monadicDC.pdf
http://okmij.org/ftp/papers/DDBinding.pdf

*** To understand https://github.com/koka-lang/koka:
https://koka-lang.github.io/koka/doc/book.html
https://www.microsoft.com/en-us/research/wp-content/uploads/2017/06/algeff-in-c-tr-v2.pdf
http://ps.informatik.uni-tuebingen.de/publications/schuster19zero.pdf

*** To understand http://maude.cs.illinois.edu/w/index.php/The_Maude_System:
https://maude.lcc.uma.es/maude321-manual-html/maude-manual.html
https://github.com/alexisread/OBJ3/blob/master/docs/iobj.pdf

*** To understand https://cuelang.org/:
https://cuelang.org/docs/concepts/logic/

*** To understand https://flix.dev/principles/:
https://flix.dev/paper/pldi2016.pdf
https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.pdf

*** To understand https://shenlanguage.org/:
https://shenlanguage.org/TBOS/tbos.html

*** 39LOC logic language http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf:
http://minikanren.org/minikanren-and-prolog.html differences between prolog and (micro/mini) kanren 
- lazy streams, threadsafe, complete interleaving search, relational (equality), 39LOC, symbolic constraints, circular checking
https://github.com/webyrd/faster-miniKanren has =/= operator, and checks types efficiently
https://arxiv.org/abs/1701.00633v1 framework for extending microkanren with constraints (CLP) - 100 lines racket macros, shows type checking as well

*** To understand https://github.com/udem-dlteam/ribbit:
http://www.iro.umontreal.ca/~feeley/papers/YvonFeeleyVMIL21.pdf

*** To understand http://www.projectoberon.com/:
https://people.inf.ethz.ch/wirth/Oberon/Oberon07.Report.pdf
https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/147091/eth-26082-02.pdf
https://concurrency.ch/Content/publications/Blaeser_Component_Operating_System_PLOS_2007.pdf

*** To understand bootstrapping on bare hardware:
https://justine.lol/sectorlisp2/
http://bootstrappable.org/
https://github.com/oriansj/stage0

*** To understand types
Tagged typing...
https://www.erlang.org/doc/reference_manual/typespec.html Atomic types

*** To understand environments, scope and capabilities
http://mumble.net/~jar/pubs/secureos/secureos.html

*** To understand types of GC:
https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator
https://github.com/carp-lang/Carp/blob/master/docs/Memory.md
https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v4.pdf
https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-908.pdf
https://concurrency.ch/Content/publications/Blaeser_ETH_Diss_2007.pdf
https://nim-lang.org/blog/2020/10/15/introduction-to-arc-orc-in-nim.html
https://austral-lang.org/spec/spec.html#goals
https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf memory allocator designed to work with RC, prioritizes data locality
https://www.researchgate.net/publication/221600574_A_Compacting_Garbage_Collector_for_Unidirectional_Heaps
https://www.researchgate.net/publication/220752316_A_study_of_concurrent_real-time_garbage_collectors Clover specifically
https://aardappel.github.io/lobster/memory_management.html
https://verdagon.dev/grimoire/grimoire

*** To understand database similarity to a distributed OS:
https://github.com/hydro-project/anna
http://db.cs.berkeley.edu/jmh/papers/anna_ieee18.pdf
https://dl.acm.org/doi/pdf/10.1145/213978.213986
https://quickwit.io/blog/chitchat/
https://github.com/chelseakomlo/talks/blob/master/2021-11-23-naval-postgrad/naval-postgrad-seminar.pdf Dist Key Gen protocols (Shamir secret shares etc)
https://arxiv.org/pdf/1906.07221.pdf

*** To understand literate programming approach:
https://bitbucket.org/joebo/pico-org/src
https://github.com/200ok-ch/org-parser EBNF grammar
https://github.com/ZaneA/LibOrgParser C org-mode parser
https://practical.li/clojure/reference/clojure-syntax/comments.html
https://github.com/nakkaya/ferret/blob/master/ferret.org

*** Syntax and homoiconicity:
http://helpin.red/Helpin'%20Red.pdf
https://koka-lang.github.io/koka/doc/book.html#sec-basics
https://www.concatenative.org/wiki/view/Lviv concatinative languages can be fast with no GC by using FBIP (functional-but-in-place) with lists/arrays/stacks/matrices
https://github.com/edn-format/edn

*** Module/Class/Prototype/Namespace/Object/Package management:
Note that red/rebol is fully dynamic, and contexts area equivalent to envs in other languages
Also note that red/rebol objects==contexts (envs)==prototypes
https://github.com/r3n/rebol-wiki/wiki/Scoping-in-Rebol
https://maude.lcc.uma.es/maude321-manual-html/maude-manualch6.html
https://github.com/nim-lang/nimble#readme

** Helloworld Examples

This syntax has changed somewhat since the initial draft of this document. Maru relies on a C compiler to bootstrap, so it was always going to require a 
lower-level system to target. This target now appears to be Forth, a minimal VM that is both lower and higher level than the underlying CPU, that can be 
boostrapped from essentially pencil and paper.
Forth is used to bootstrap new hardware, and can run in under 1k RAM. As a dual of lisp it can be thought of as a stream (of atoms) consumer, whereas lisp forms an 
AST from the source text atoms and then operates on that. As far as parsing goes then, forth is a left->right stream of words, lisp is parsed left-right and executed
right->left effectively, as evaluation starts at the leaves and works up the AST.
Executing right->left is similar to mathematics in that for f(g(x)) we evaluate g(x) and plug that into f().
Traditional forth has no variables, it is a point-free language and the programmer has to keep track of the stack state somehow. It is less easy to acclimatise to
someone else's code than more explicit languages. Rebol is a concatenative language that handles variables as well, and the syntax is somewhat modelled after it.

*** Language rules
- Code is parsed right->left similar (overall) to lisp, but we consume/execute the stream of atoms/words immediately unlike lisp which consumes the whole code block first
- Whitespace is the separator between atoms. Code is not indentation sensitive.
- There will be a standard lint style. Obviously this can be abandoned/overriden where required eg. code-inside-messages, personal usage.
- Symbols are normalised with respect to capitalization eg. total = TOTAL, but will respect the capitalization at assignment.
- Brackets are all semantically the same ie. () = {} = [] = <>. As such we can colour the code depending on form or nested depth.
- Brackets denote a block, which may have symbols for static or dynamic variables in. We need a word to define what happens to the block eg. fn [mycode] compiles an anonymous function
- Brackets do not require whitespace surrounding them
- Atoms are typed, starting with fundamental types and extending to compound (user) types
- : at the end of an atom is assign. This extends to linking related attributes eg. myint: int: 10 assigns 10 to myint, which is an integer
- Adopting the style of Rebol's dialects, Special forms are simply a type constructor eg. IF is a function, which is also a type, it's init has a form of [condition][body]
- We can construct ASTs using branching forms eg. IFELSE or simply PAIRs. As this is a homoiconic syntax ie. code=data, we can build complex control flow incrementally
- Control flow is first-class ie. we can use algebraic effects to branch the control flow. This can be built up incrementally including with pattern-matching
- There is the potential here to develop cycles. Dadelus-style checking in conjunction with a backref hashtable is used at compiletime to try to locate these cycles
- Similarly for GC, we use reference counting (hard realtime managed) on acyclic structures with the above cycle checking, which can be done incrementally/realtime.
- For the RC to be threadsafe, we use 2 PNcounters on the RC field, or an atomic cpu instruction (implementation dependent).
- Types and therefore signatures (aka a parameter block) can be generically typed
- Truth ie. booleans, empty lists, nulls, undefined values, is as per Kamilalisp. We strive for a mathematically consistent base here
- Contrary to Lisps, blocks don't evaluate by default in an expression, you need to eval them explicitly
- eval returns the first expression in a block (as a result of right->left evaluation)
- Naked anonymous functions are compiled and executed immediately. This gives us the ability to have an interactive shell/repl with compilation
- Naked blocks are also evaluated and executed immediately. The shell implicitly adds a surrounding bracket and eval to the input
- The function form is fn [params][body] We usually use () for the parameter block, and [] for the body
- , is a form separator. It closes all brackets below the form bracket, see the complex example.
- Comments, help pages (reference), recursive docs, wizards and tests must be inside a module, this enforces scoped and linked documentation.

So for helloworld we have: . "Helloworld"
which compiles the "Helloworld" string to a literal, and stores it in temp storage (on a data stack),
compiles a link to the print instruction and stores that next to the literal (on the stack).
As there are implicit brackets around the shell command, this is an anonymous block and is executed immediately.

As a function helloworld is: fn ()[. "Helloworld"] 
which compiles the "Helloworld" string to a literal, and stores it in temp storage (on a data stack),
compiles a link to the print instruction and stores that next to the literal (on the stack),
closes the block, discards the empty parameter block, reads that this is a function, reads then that it is anonymous,
and so executes the block and clears the temp storage (pops the stack)

A more complex example is:
myword: fn (arg1: int arg2: int: 10 -> total)[* arg1 arg2] 
this assigns the myword symbol to this new function. arg1 is an integer and arg2 is as well, with a default value of 10. 
The output algebraic effect of this function is TOTAL and the function simply adds two integers. -> is the separator between input and output attributes.
To execute this function we do at the shell:
. myword + 6 7,8
This shows the form separator at work. We could use brackets to get: [. myword [+ [6 7]] 8] but the form separator shows where the close bracket is 
ie. + operates on only two atoms, leaving two atoms for myword to correctly evaluate
+ is a variadic function that can sum multiple atoms, leading to the potential ambiguity (without the separator) of [. myword [+ [6 7 8]]] which would fail.

In terms of execution, we parse right->left pushing 8 7 6 onto the stack in that order, then adding (popping) the top two elements and pushing the result 13,
then executing myword which adds the top two elements, pushing 21 onto the stack for print to consume and output to the shell.

Types are checked at compiletime. auto-typecasting is allowed if a type relationship has been defined eg. int (is a subset of) <- float
Variables are assumed to be dynamic unless annotated eg. mystaticint: static: int
Dynamic variables are more deterministic at runtime unlike static variables which have to be looked up, potentially up the scoping tree.
For static variable handling see the Dreams system. We evaluate static variables with DID rather than EVAL/DOES as they are fixed at compiletime.
Variables and other atoms can have several attributes, linked by assign chains: Shared (ie. implements threadsafe accessors), local (destroyed after execution),
acyclic (refs are guaranteed to be by the compiletime cycle checker), type, defaultvalue, static, mutable, endian,
effect (eg. cpu register, input address, mustberefcounted).

Modules can be considered object templates, instantiated at runtime. Following the Dreams system they are denoted by: mymod: mod attributes...[public][private]
All words go into the dictionary aka symbol table, but private ones are hidden - access is via a concurrent dictionary type which manages the word/module capabilities
A signed ULID/contenthash is created when the module is created, this is the unique module ID.
From this, we can see that types are simply modules with a constructor form, identity function, and getter and setter handles for capability management.
(ie. if you have the setter handle for the instantiated type, you can modify it, if you have the getter you can access it).
ACI resolvers in the type allow them to fit into lattices, which allows for fully concurrent access.

Modules are namespaced by the module ID (called the head) - an optionally signed (ie. the public key) (hash of the module+ulid date).
We may require encrypted and signed links (and root field) to other modules, to be able to form a hash graph. Form of the graph:
{head, root, encryptedlinks{ linkID: { senderpublickey, recipientpublickey, encryptedbody }}}
A new version of the module can then have a secure link to the older version. We keep a version field as well for convenience.
Getters/setters can require UCAN tokens for authorization, other than just the word address (generally local access).
As such, we have several types of modules available in the language, inheriting from the base module prototype which always has a module ID.

Environments are instantiated forms of modules, and contain capabilities ie. W7
Bindings move between modules via another kind of environment-like object called a structure. A structure is a particular package's implementation of a particular 
interface; and an interface is a set of names, with optional types attached ie. a type.
The complier enforces these capabilities

Comments, assertions and tests are all a live part of the codebase. As per many systems (Elixir testdocs, Retroforth unu, Clojure orgmode) we try to create a literal
system here, but possibly more structured than previous systems.
For speed, we prefer single-pass compilation, and to that end djot + latex + mermaid is a great documentation set of DSLs. 
From there we require a way of interleaving with the code and scoping comments to specific functions/atoms/blocks/modules - we require 'recursive documentation'
If we take the literal approach ie. docs first, we mark code via ```minim blocks, and from code we mark docs via ```jdot. This can be recursive to selectively expose code
Similarly with tests, we mark a test for a function with a linked test block inside the surrounding docs...
Comments are separate from documentation, as they are details/why for the programmer rather than the overview/why of a piece of code. We can also document word signatures
and document the references between words, though this may be better/more comprehensible to follow an execution thread.
As all of these are scoped, at compiletime you can decide whether to include or evaluate them (comments and code).
As such, help pages can be either the documented source code, in-memory literals, or compiled to a dedicated file (like Freeforth). 
In all cases the help' word does a regex on strings.
Wizards are basically a link from one documentation block to another. Djot notation defines a reference link which is used here to move [forward][moduleID]
and [back][moduleID] through the documentation blocks. We can also use reference links within multiple blocks in a module.
As the compiler passes over these blocks, we can use this recursive exposure to generate documentation/calculations etc. to output a document snapshot like a report.
If we have a constraint-modelled redUI/ksworld (but with Dadelus temporal specification and push dataflow based on algebraic effects with before/after substitution)
DSL as well, then we can define interactive scenes for these wizards.

#+index: roadmap
* Roadmap

In order to create a system that can fit all the feature requirements, Minim steals ideas shamelessly from other languages, but we need to find compatible features.
Maru is a practical dynamic COLA, ie. the user has control over all phases of application development, deployment and execution inc hardware eg. FPGA backend.
As such, we should be able to iteratively evolve the maru system to include other features that we require, specifically fine-grained control over static types, for ease of reasoning,
and optimisation of execution. 

If we wish to add this control, and concurrency to the system, we require a solid theory of the interations between dynamic and statically bound variables, together with concurrent features.
Wat gives us this delimited dynamic binding theory in a portable form. Wat makes use of the underlying language types (see DDBinding paper), so wat should be able to use maru's user-defined type system.

From the Flix language, we can see that it is beneficial to have an embedded first-class logic language, as well as a unifying set of lattice types.
In particular the lattice treatment of null in cuelang is a good indicator of the advantages of unification, as well as in Anna, where lattices are used to resolve conflicts.
The static analyis of memory usage in ASAP makes use of three-value-logic types extensively.
As such, we look to extend maru's types with lattice types and three-value-logic types.

From Shen, Flix and Maude, we can see that we can use an embedded logic language to do formal verification, of which type checking is one aspect.
Due to the requirement for metacircularity, we require an extremely compact logic language so that we may be able to compile it from the code we have proven with it.
Microkanren is 39LOC and can perform the Calculus Of Constructions (CoC), Membership Equational logic (as MEqLogic is a subset of MKFOL - many-kinded first-order logic)
and relational logic. 
Furthermore, we can follow the example of shen to provide type-checking and inference via sequent calculus - we use microkanren to compile the sequent calculus
statements down to the underlying functional language implementation.

Lastly, with regard to metacircularity, comments in the language can be in org-mode form, hence we need an org-mode parser (using EBNF grammar) and tangling tools
to complete the full metacircular toolchain.

One of the more active debates in the Haskell community is with regard to I/O as a side effect of monadic programming. Perhaps a more flexible model lies with
Algebraic Effects, and given that Koka makes good use of them in conjunction with static (Hindley-Milner) type analysis and concurrency with dynamic binding,
we can clearly see that these features dovetail well with maru in extending our featureset to that required by minim.
Koka is written in Haskell, but the team maintain C libraries, and we also may be able to use zero-cost effect handlers to provide a path to controlling side effects
and transforming dynamic bindings and operation to static constructs.

To add to the static needs, to be deterministic ie. realtime, we cannot use a GC to manage memory due to the unpredictability *and* size requirements of microcontrollers
Both Perceus reference counting and ASAP static analysis require a good formalism of computation as per Koka to be able to fully check memory bounds (including cycles).
It is clear from Sectorlisp and Ribbit that we can run GC in a small system, however it is also clear that the less garbage generated, the less there is to clear up -
Sectorlisp makes do with immutable cells and acyclic operation. Concatenative languages can go one better in that mutable data is passed in-place (in memory)
from function to function, so there is little to clear up.
Koka uses a phrase FBIP, functional-but-in-place, to describe a similar set of optimisations for monadic ie. chainable operations, and we aim to use that here,
along with a suitable concatenative syntax.

With respect to the concatenative syntax required, we look to be able to elide function parameters, so that we indicate that the operations on the parameters 
can be done in-place eg. fg(my_stack) or fg(my_array).
Snake case eg. my_function appears to be more compatible across languages and platforms (some langs eg. Oberon and platforms eg. Windows are case insensitive,
and SQL and Python don't play nicely with kebab case eg. my-function), so we should make an attempt to use that. 
Syntax should be IDE-agnostic, and that also goes for serialisation and encoding eg. urlencoding. As such, significant whitespace can be a hindrance.
Lisp has a very uniform syntax which helps it's homoiconicity (note that Red is homoiconic as well though) and does not distinguish between different forms with it's
braces eg. the difference between a code region {}, function {}, param (), array [] etc. is not there in lisp, we should attempt to remove line noise by elision of
syntax where possible simliarly to Koka.
Clojure's Edn format illustrates some advantages of using a language subset for configuration, serialisation and data. If we have language features segregated into
modules, we can restrict module usage for different scenarios eg. configuration files should only be able to use a non-turing-complete set of operations.
Binary serialisation is a useful feature here, both for messaging, and for the static/bytecode parts of the operating system. We look to take features from Ribbit in
serialising the entire language, and bytecode format, to a compact representation (binary).

With the above modularisation, we can prove the safety of a format much easier - if we treat each (pure ie. no side-effects, just mathematically sound) module as a
theory, or set of theories if we do imports, we can prove that the format adheres to certain principles eg. turing-incomplete.
In a fully dynamic system, a class and it's instance are both objects, as with modules and packages, prototypes and children, traits and types, envs and parents etc.
It is still useful to refer to the above constructs by their semantic name, despite any underlying execution similarities.

To be able to build the system from scratch ie. not relying on even firmware, we need to look at bootstrapping.
The impetus here is one of security, technically we cannot trust anything not checked by-eye. 
In the most primitive case (stage0), we would look to type in instructions that create a hex editor, with which we can assemble a hex assembler, and then use that
to build minim. Sectorlisp is very small so a good model for how to build a minimal system, it also is portable across different platforms, though interpreted.
Ribbit has an AOT compiler and multiple VM backends, so Minim will follow an architecture of AOT compiling to bytecode, with the VM being modeled around a Sectorlisp
build toolchain.

* Atomic types
owner bit, owner/weak ref
type safety in w7 is extension of safe parent types ie. intersection visibility
read and write barriers can be done in object getters and setters

* Memory management
Memory management strategies fundamentally affect the language - do we want hard realtime management? Do we wish to manage cyclic data structures? How intrusive do we
want this to be for the programmer? Are we allowing shared (between threads) mutable state? Do we have object finalizers?

Minim has the following requirements:
Hard realtime, handle cycles, shared mutable state.
With the current state of memory management, this requires that we make tradeoffs in a fine-grained fashion 
eg. shared mutable state might be used for some data structures and thus have a write barrier (slower), stacks are per thread though and run quicker.
The vale language is effectively built around it's management strategies, and encourages a divide-and-conquer approach. Minim will do the same.
Looking at Forth which is very memory efficient, we can see that the callstack (return stack) and the datastack manage to clean up memory efficiently 
- un-used results are simply popped off the stacks. The Forth dictionary, in most Forths, is unbounded ie. we can consider it a symbol table constructed from a linked
list, which is left to grow with a restart compacting it. 
In addition, the use of objects will require management. Dreams pushes the objects into the dictionary, with stacks managing the object usage.
This dictionary is a good candidate for several memory management techniques, mostly stolen from Vale:
We can start with generational references as a substitute for reference counting. Immutable region borrowing (Vale, isolates in Nim and Pony),
FBIP (See Austral, Koka), ownership analysis (lobster) and scope-based management (See ARC in Nim) can all be used to elide these generational references,
through use of microkanren-based constraint modelling at compile time. These imply the use of linear types ie. an object can only have one owner, 
any other client can read using a reference.

The remaining issues are how to deal with cyclic data structures (and resulting GC cycles), and how to interleave these different management types.
As per Vale and the arena blog post above, we can select compatible strategies, in this case generational refs with all analysis done using microkanren.
For cylic structures, provided the cyclic structure is within a region, we are fine as the region can be collected. If the cyclic structure does not modify global 
references we have acyclic roots, and so should be able to avoid GC cycles and collect the cyclic structure.
For the Forth dictionary, it can be considered unidirectional. Under unidrectional memory, we cannot have cycles, unless we use a reference pointing backwards.
This can be considered a candidate for cycle checking, with the owner being the parent, with child back and forward refs linked to the lifetime.
Back references are also known as weak refs, removing them or the parent has no bearing on the weak ref, so cycle breaking happens automatically when the parent is dropped.
As such, back references in the context of unidrectional memory can be considered a mechanism for creating cycles, all cycles must contain a weak reference.
References can be annotated by the programmer (owner or weak), so they choose where cycle-breaking occurs, or left to the compiler to work out - all backrefs are weak.
To enforce this unidirectional memory, we need to ensure new allocations are in the memory direction, and try to compact the heap periodically.
The compaction algorithm can be found in the above reading list, but also appears in Freeforth (Hid'm word) and the GC in Sectorlisp2.
We can run this incrementally on a dictionary/symbol table by marking dead memory blocks, and a pointer to where in the heap we have got to.
This works as we have a base entry point rather than direct entry to the table, direct references would have to be updated on compaction.

For runtime, memory gets and sets happen through the type handles, which is where we can put the read/write barriers, as well as GC instruction insertion - we don't 
require a scheduler this way, and GC can be estimated based on the object usage.
The compiler can enforce that strong refs are correctly ordered, so we only require an ispointer bit to indicate and enforce bounds checking.
We may not need to compact used memory all the time, the allocator could flag when it requires a weak ref ie. a back pointer, which may fit in uncompacted memory. 
This is an optimisation that can be done at a later date.

Note that the GC algorithm works only for single threads, for shared memory we require a way of managing copy operations while mutators operate.
The Clover collector blocks on copy while there is a magic generation value (max) in the generation pointer. We can use a CAS bit instead, as we have 2 spare alignment
bits to work with (16bit OS), given the generation pointer. We scan and compact simultaneously, with object pointer updates after. The GC has exclusive access to the
CAS bit.

All of the analysis-based management will be run at compile time, using the constraint modelling. Kanrens work upon lists as the fundamental construct
(we can model matrices and higher tensors as a list of arrays), so will work well on memory constructs in minim. Note that analysis will depend on the type of an
object, so the type checker will also be written in microkanren, same as for capability management, which can also be considered a linear-type (ownership) problem.

So for an object, we require a generational ref which is pointer+tag, we require a type pointer, and a collection bit for the compactor (?). Other configurable bits ...
pointer bit (type bits), owner/weak bit allows us to do GC at runtime as well as compile time.
cas bit works as only one owner/setter ref.

Compiler algo is determine object, go to tagged object to get pointers, check annotated pointer refs obey weak ref rule WRR, compile object allocating pointers per WRR
GC algo is check object header, go to tagged object to get pointers, check pointer refs a la uniGGC and compact

* License

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

* Implementation

** Metacircular implementation

For every module there is a C equivalent, for bootstrapping.
We are starting with the maru implementations, and building on that. As such, the syntax is lisp to start with.
We list the maru-lisp (later minim) modules after the C versions.

** Modules

*** bootstrap/eval.c

The core module is eval.c. boot.c and emit.c are run after this.

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/eval.c
// last edited: 2012-08-24 13:02:22 by piumarta on emilia.local

#define _ISOC99_SOURCE 1
#define _BSD_SOURCE 1

#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <stdarg.h>
#include <sys/types.h>
#include <errno.h>
#include <wchar.h>
#include <locale.h>
#include <math.h>
#include <assert.h>

extern int isatty(int);

#if defined(WIN32)
# define swnprintf(BUF, SIZE, FMT, ARG) swprintf(BUF, FMT, ARG)
#else
# define swnprintf swprintf
#endif

#define	TAG_INT	1
//#define	LIB_GC	1

#define GC_APP_HEADER	int type;

#if (LIB_GC)
# include "libgc.c"
#else
# include "gc.c"
#endif
#include "wcs.c"
#include "buffer.c"

union Object;

typedef union Object *oop;

typedef oop (*imp_t)(oop args, oop env);

#define nil ((oop)0)

enum { Undefined, Data, Long, Double, String, Symbol, Pair, _Array, Array, Expr, Form, Fixed, Subr, Variable, Env, Context };

struct Data	{ };
struct Long	{ long	   bits; };
struct Double	{ double   bits; };
struct String	{ oop      size;  wchar_t *bits; };	/* bits is in managed memory */
struct Symbol	{ wchar_t *bits; };
struct Pair	{ oop 	   head, tail, source; };
struct Array	{ oop      size, _array; };
struct Expr	{ oop 	   name, defn, ctx, profile; };
struct Form	{ oop 	   function, symbol; };
struct Fixed	{ oop      function; };
struct Subr	{ imp_t    imp;  wchar_t *name;  int profile; };
struct Variable	{ oop 	   name, value, env, index, type; };
struct Env	{ oop 	   parent, level, offset, bindings, stable; };
struct Context	{ oop 	   home, env, bindings, callee, pc; };

union Object {
  struct Data		Data;
  struct Long		Long;
  struct Double		Double;
  struct String		String;
  struct Symbol		Symbol;
  struct Pair		Pair;
  struct Array		Array;
  struct Expr		Expr;
  struct Form		Form;
  struct Fixed		Fixed;
  struct Subr		Subr;
  struct Variable	Variable;
  struct Env		Env;
  struct Context	Context;
};

static void fatal(char *reason, ...);

#define setType(OBJ, TYPE)		(ptr2hdr(OBJ)->type= (TYPE))

#if (TAG_INT)
  static inline int getType(oop obj)	{ return obj ? (((long)obj & 1) ? Long : ptr2hdr(obj)->type) : Undefined; }
#else
  static inline int getType(oop obj)	{ return obj ? ptr2hdr(obj)->type : Undefined; }
#endif

#define is(TYPE, OBJ)			((OBJ) && (TYPE == getType(OBJ)))

#if defined(NDEBUG)
# define checkType(OBJ, TYPE) OBJ
#else
# define checkType(OBJ, TYPE) _checkType(OBJ, TYPE, #TYPE, __FILE__, __LINE__)
  static inline oop _checkType(oop obj, int type, char *name, char *file, int line)
  {
    if (obj && !((long)obj & 1) && !ptr2hdr(obj)->used)	fatal("%s:%i: attempt to access dead object %s\n", file, line, name);
    if (!is(type, obj))					fatal("%s:%i: typecheck failed for %s (%i != %i)\n", file, line, name, type, getType(obj));
    return obj;
  }
#endif

#define get(OBJ, TYPE, FIELD)		(checkType(OBJ, TYPE)->TYPE.FIELD)
#define set(OBJ, TYPE, FIELD, VALUE)	(checkType(OBJ, TYPE)->TYPE.FIELD= (VALUE))

#define getHead(OBJ)	get(OBJ, Pair,head)
#define getTail(OBJ)	get(OBJ, Pair,tail)

#define setHead(OBJ, VAL)	set(OBJ, Pair,head, VAL)
#define setTail(OBJ, VAL)	set(OBJ, Pair,tail, VAL)

static oop car(oop obj)			{ return is(Pair, obj) ? getHead(obj) : nil; }
static oop cdr(oop obj)			{ return is(Pair, obj) ? getTail(obj) : nil; }

static oop caar(oop obj)		{ return car(car(obj)); }
static oop cadr(oop obj)		{ return car(cdr(obj)); }
static oop cddr(oop obj)		{ return cdr(cdr(obj)); }
//static oop caaar(oop obj)		{ return car(car(car(obj))); }
//static oop cadar(oop obj)		{ return car(cdr(car(obj))); }
static oop caddr(oop obj)		{ return car(cdr(cdr(obj))); }
static oop cadddr(oop obj)		{ return car(cdr(cdr(cdr(obj)))); }

#define newBits(TYPE)	_newBits(TYPE, sizeof(struct TYPE))
#define newOops(TYPE)	_newOops(TYPE, sizeof(struct TYPE))

static oop _newBits(int type, size_t size)	{ oop obj= GC_malloc_atomic(size);	setType(obj, type);  return obj; }
static oop _newOops(int type, size_t size)	{ oop obj= GC_malloc(size);		setType(obj, type);  return obj; }

static oop symbols= nil;
static oop s_define= nil, s_set= nil, s_quote= nil, s_lambda= nil, s_let= nil, s_quasiquote= nil, s_unquote= nil, s_unquote_splicing= nil, s_t= nil, s_dot= nil, s_bracket= nil, s_brace= nil; //, s_in= nil;
static oop f_lambda= nil, f_let= nil, f_quote= nil, f_set= nil, f_define;
static oop globals= nil, expanders= nil, encoders= nil, evaluators= nil, applicators= nil;
static oop arguments= nil, backtrace= nil, input= nil, output= nil;

static int opt_b= 0, opt_g= 0, opt_O= 0, opt_p= 0, opt_v= 0;

static oop traceStack= nil;
static int traceDepth= 0;

static oop newData(size_t len)		{ return _newBits(Data, len); }

#if (TAG_INT)
  static inline int  isLong(oop x)	{ return (((long)x & 1) || Long == getType(x)); }
  static inline oop  newLong(long x)	{ if ((x ^ (x << 1)) < 0) { oop obj= newBits(Long);  set(obj, Long,bits, x);  return obj; }  return ((oop)((x << 1) | 1)); }
  static inline long getLong(oop x)	{ if ((long)x & 1) return (long)x >> 1;  return get(x, Long,bits); }
#else
# define     isLong(X)			is(Long, (X))
  static oop newLong(long bits)		{ oop obj= newBits(Long);  set(obj, Long,bits, bits);  return obj; }
# define     getLong(X)			get((X), Long,bits)
#endif

static void   setDouble(oop obj, double bits)	{		memcpy(&obj->Double.bits, &bits, sizeof(bits)); }
static double getDouble(oop obj)		{ double bits;  memcpy(&bits, &obj->Double.bits, sizeof(bits));  return bits; }

#define isDouble(X)			is(Double, (X))

static inline int isNumeric(oop obj)	{ return isLong(obj) || isDouble(obj); }

static oop newDouble(double bits)	{ oop obj= newBits(Double);  setDouble(obj, bits);  return obj; }

static oop _newString(size_t len)
{
  wchar_t *gstr= (wchar_t *)_newBits(-1, sizeof(wchar_t) * (len + 1));	GC_PROTECT(gstr);	/* + 1 to ensure null terminator */
  oop       obj= newOops(String);				GC_PROTECT(obj);
  set(obj, String,size, newLong(len));				GC_UNPROTECT(obj);
  set(obj, String,bits, gstr);					GC_UNPROTECT(gstr);
  return obj;
}

static oop newStringN(wchar_t *cstr, size_t len)
{
  oop obj= _newString(len);
  memcpy(get(obj, String,bits), cstr, sizeof(wchar_t) * len);
  return obj;
}

static oop newString(wchar_t *cstr)
{
    return newStringN(cstr, wcslen(cstr));
}

static int stringLength(oop string)
{
  return getLong(get(string, String,size));
}

static oop newSymbol(wchar_t *cstr)	{ oop obj= newBits(Symbol);	set(obj, Symbol,bits, wcsdup(cstr));			return obj; }

static oop newPair(oop head, oop tail)	{ oop obj= newOops(Pair);	set(obj, Pair,head, head);  set(obj, Pair,tail, tail);	return obj; }

static oop newPairFrom(oop head, oop tail, oop source)
{
  oop obj= newOops(Pair);
  set(obj, Pair,head, 	head);
  set(obj, Pair,tail, 	tail);
  set(obj, Pair,source, get(source, Pair,source));
  return obj;
}

static oop newArray(int size)
{
  int cap=  size ? size : 1;
  oop elts= _newOops(_Array, sizeof(oop) * cap);	GC_PROTECT(elts);
  oop obj=   newOops( Array);				GC_PROTECT(obj);
  set(obj, Array,_array, elts);
  set(obj, Array,size, newLong(size));			GC_UNPROTECT(obj);  GC_UNPROTECT(elts);
  return obj;
}

static int arrayLength(oop obj)
{
  return is(Array, obj) ? getLong(get(obj, Array,size)) : 0;
}

static oop arrayAt(oop array, int index)
{
  if (is(Array, array)) {
    oop elts= get(array, Array,_array);
    int size= arrayLength(array);
    if ((unsigned)index < (unsigned)size)
      return ((oop *)elts)[index];
  }
  return nil;
}

static oop arrayAtPut(oop array, int index, oop val)
{
  if (is(Array, array)) {
    int size= arrayLength(array);
    oop elts= get(array, Array,_array);
    if ((unsigned)index >= (unsigned)size) {
      GC_PROTECT(array);
      int cap= GC_size(elts) / sizeof(oop);
      if (index >= cap) {
	while (cap <= index) cap *= 2;
	oop oops= _newOops(_Array, sizeof(oop) * cap);
	memcpy((oop *)oops, (oop *)elts, sizeof(oop) * size);
	elts= set(array, Array,_array, oops);
      }
      set(array, Array,size, newLong(index + 1));
      GC_UNPROTECT(array);
    }
    return ((oop *)elts)[index]= val;
  }
  return nil;
}

static oop arrayAppend(oop array, oop val)
{
  return arrayAtPut(array, arrayLength(array), val);
}

static oop arrayInsert(oop obj, size_t index, oop value)
{
  size_t len= arrayLength(obj);
  arrayAppend(obj, value);
  if (index < len) {
    oop  elts= get(obj, Array,_array);
    oop *oops= (oop *)elts + index;
    memmove(oops + 1, oops, sizeof(oop) * (len - index));
  }
  arrayAtPut(obj, index, value);
  return value;
}

static oop oopAt(oop obj, int index)
{
  if (obj && !isLong(obj) && !GC_atomic(obj)) {
    int size= GC_size(obj) / sizeof(oop);
    if ((unsigned)index < (unsigned)size) return ((oop *)obj)[index];
  }
  return nil;
}

static oop oopAtPut(oop obj, int index, oop value)
{
  if (obj && !isLong(obj) && !GC_atomic(obj)) {
    int size= GC_size(obj) / sizeof(oop);
    if ((unsigned)index < (unsigned)size) return ((oop *)obj)[index]= value;
  }
  return nil;
}

static oop newExpr(oop defn, oop ctx)
{
  oop obj= newOops(Expr);		GC_PROTECT(obj);
  set(obj, Expr,defn,    defn);
  set(obj, Expr,ctx,     ctx);
  set(obj, Expr,profile, newLong(0));	GC_UNPROTECT(obj);
  return obj;
}

static oop newForm(oop fn, oop sym)	{ oop obj= newOops(Form);	set(obj, Form,function, fn);	set(obj, Form,symbol, sym);	return obj; }
static oop newFixed(oop function)	{ oop obj= newOops(Fixed);	set(obj, Fixed,function, function);				return obj; }

static oop newSubr(imp_t imp, wchar_t *name)
{
  oop obj= newBits(Subr);
  set(obj, Subr,imp,     imp);
  set(obj, Subr,name,    name);
  set(obj, Subr,profile, 0);
  return obj;
}

static oop newVariable(oop name, oop value, oop env, int index)
{
  oop obj= newOops(Variable);			GC_PROTECT(obj);
  set(obj, Variable,name,  name);
  set(obj, Variable,value, value);
  set(obj, Variable,env,   env);
  set(obj, Variable,index, newLong(index));
  set(obj, Variable,type,  0);			GC_UNPROTECT(obj);
  return obj;
}

static oop newEnv(oop parent, int level, int offset)
{
  oop obj= newOops(Env);			GC_PROTECT(obj);
  set(obj, Env,parent,   parent);
  set(obj, Env,level,    newLong((nil == parent) ? 0 : getLong(get(parent, Env,level)) + level));
  set(obj, Env,offset,   newLong(offset));
  set(obj, Env,bindings, newArray(0));		GC_UNPROTECT(obj);
  return obj;
}

static oop newBaseContext(oop home, oop caller, oop env)
{
  oop obj= newOops(Context);			GC_PROTECT(obj);
  set(obj, Context,home,     home);
  set(obj, Context,env,      env);
  set(obj, Context,bindings, newArray(0));	GC_UNPROTECT(obj);
  return obj;
}

static oop newContext(oop home, oop caller, oop env)
{
  oop obj= nil;
  //xxx fix escape analysis for nested lambdas with free variables
#if 0
  if ((nil != caller) && (nil != (obj= get(caller, Context,callee)))) {
    set(obj, Context,home, home);
    set(obj, Context,env,  env);
    return obj;
  }
#endif
  obj= newBaseContext(home, caller, env);
  if (nil != caller) set(caller, Context,callee, obj);
  return obj;
}

static void dump(oop);
static void dumpln(oop);

static oop findLocalVariable(oop env, oop name)
{
    oop bindings= get(env, Env,bindings);
    int index= arrayLength(bindings);
    while (--index >= 0) {
	oop var= arrayAt(bindings, index);
	if (get(var, Variable,name) == name)
	    return var;
    }
    return nil;
}

static oop findVariable(oop env, oop name)
{
    while (nil != env) {
	oop var= findLocalVariable(env, name);
	if (nil != var) return var;
	env= get(env, Env,parent);
    }
    return nil;
}

static oop lookup(oop env, oop name)
{
  oop var= findVariable(env, name);
  if (nil == var) fatal("undefined variable: %ls", get(name, Symbol,bits));
  return get(var, Variable,value);
}

static oop define(oop env, oop name, oop value)
{
  oop bindings= get(env, Env,bindings);
  {
    int index= arrayLength(bindings);
    while (--index >= 0) {
      oop var= arrayAt(bindings, index);
      if (get(var, Variable,name) == name) {
	set(var, Variable,value, value);
	return var;
      }
    }
  }
  int off= getLong(get(env, Env,offset));
  oop var= newVariable(name, value, env, off);	GC_PROTECT(var);
  arrayAppend(bindings, var);			GC_UNPROTECT(var);
  set(env, Env,offset, newLong(off + 1));
  if (is(Expr, value) && (nil == get(value, Expr,name)))
    set(value, Expr,name, name);
  return var;
}

static int isGlobal(oop var)
{
  oop env= get(var, Variable,env);
  return (nil != env) && (0 == getLong(get(env, Env,level)));
}

static oop newBool(int b)		{ return b ? s_t : nil; }

static oop intern(wchar_t *string)
{
  ssize_t lo= 0, hi= arrayLength(symbols) - 1, c= 0;
  oop s= nil;
  while (lo <= hi) {
    size_t m= (lo + hi) / 2;
    s= arrayAt(symbols, m);
    c= wcscmp(string, get(s, Symbol,bits));
    if      (c < 0)	hi= m - 1;
    else if (c > 0)	lo= m + 1;
    else		return s;
  }
  GC_PROTECT(s);
  s= newSymbol(string);
  arrayInsert(symbols, lo, s);
  GC_UNPROTECT(s);
  return s;
}

#include "chartab.h"

static int isPrint(int c)	{ return (0 <= c && c <= 127 && (CHAR_PRINT    & chartab[c])) || (c >= 128); }
static int isAlpha(int c)	{ return (0 <= c && c <= 127 && (CHAR_ALPHA    & chartab[c])) || (c >= 128); }
static int isDigit10(int c)	{ return (0 <= c && c <= 127 && (CHAR_DIGIT10  & chartab[c])); }
static int isDigit16(int c)	{ return (0 <= c && c <= 127 && (CHAR_DIGIT16  & chartab[c])); }
static int isLetter(int c)	{ return (0 <= c && c <= 127 && (CHAR_LETTER   & chartab[c])) || (c >= 128); }

#define DONE	((oop)-4)	/* cannot be a tagged immediate */

static oop currentPath= 0;
static oop currentLine= 0;
static oop currentSource= 0;

static void beginSource(wchar_t *path)
{
  currentPath= newString(path);
  currentLine= newLong(1);
  currentSource= newPair(currentSource, nil);
  set(currentSource, Pair,source, newPair(currentPath, currentLine));
}

static void advanceSource(void)
{
  currentLine= newLong(getLong(currentLine) + 1);
  set(currentSource, Pair,source, newPair(currentPath, currentLine));
}

static void endSource(void)
{
  currentSource= get(currentSource, Pair,head);
  oop src= get(currentSource, Pair,source);
  currentPath= car(src);
  currentLine= cdr(src);
}

static oop read(FILE *fp);

static oop readList(FILE *fp, int delim)
{
  oop head= nil, tail= head, obj= nil;
  GC_PROTECT(head);
  GC_PROTECT(obj);
  obj= read(fp);
  if (obj == DONE) goto eof;
  head= tail= newPairFrom(obj, nil, currentSource);
  for (;;) {
    obj= read(fp);
    if (obj == DONE) goto eof;
    if (obj == s_dot) {
      obj= read(fp);
      if (obj == DONE)		fatal("missing item after .");
      tail= set(tail, Pair,tail, obj);
      obj= read(fp);
      if (obj != DONE)		fatal("extra item after .");
      goto eof;
    }
    obj= newPairFrom(obj, nil, currentSource);
    tail= set(tail, Pair,tail, obj);
  }
eof:;
  int c= getwc(fp);
  if (c != delim) {
    if (c < 0) fatal("EOF while reading list");
    fatal("mismatched delimiter: expected '%c' found '%c'", delim, c);
  }
  GC_UNPROTECT(obj);
  GC_UNPROTECT(head);
  return head;
}

static int digitValue(wint_t c)
{
  switch (c) {
    case '0' ... '9':  return c - '0';
    case 'A' ... 'Z':  return c - 'A' + 10;
    case 'a' ... 'z':  return c - 'a' + 10;
  }
  fatal("illegal digit in character escape");
  return 0;
}

static int isHexadecimal(wint_t c)
{
  switch (c) {
    case '0' ... '9':
    case 'A' ... 'F':
    case 'a' ... 'f':
      return 1;
  }
  return 0;
}

static int isOctal(wint_t c)
{
  return '0' <= c && c <= '7';
}

static int readChar(wint_t c, FILE *fp)
{
  if ('\\' == c) {
    c= getwc(fp);
    switch (c) {
      case 'a':   return '\a';
      case 'b':   return '\b';
      case 'f':   return '\f';
      case 'n':   return '\n';
      case 'r':   return '\r';
      case 't':   return '\t';
      case 'v':   return '\v';
      case 'u': {
	wint_t a= getwc(fp), b= getwc(fp), c= getwc(fp), d= getwc(fp);
	return (digitValue(a) << 12) + (digitValue(b) << 8) + (digitValue(c) << 4) + digitValue(d);
      }
      case 'x': {
	int x= 0;
	if (isHexadecimal(c= getwc(fp))) {
	  x= digitValue(c);
	  if (isHexadecimal(c= getwc(fp))) {
	    x= x * 16 + digitValue(c);
	    c= getwc(fp);
	  }
	}
	ungetwc(c, fp);
	return x;
      }
      case '0' ... '7': {
	int x= digitValue(c);
	if (isOctal(c= getwc(fp))) {
	  x= x * 8 + digitValue(c);
	  if (isOctal(c= getwc(fp))) {
	    x= x * 8 + digitValue(c);
	    c= getwc(fp);
	  }
	}
	ungetwc(c, fp);
	return x;
      }
      default:
	if (isAlpha(c) || isDigit10(c)) fatal("illegal character escape: \\%c", c);
	return c;
    }
  }
  return c;
}

static oop read(FILE *fp)
{
  for (;;) {
    wint_t c= getwc(fp);
    switch (c) {
      case WEOF: {
	return DONE;
      }
      case '\n': {
	while ('\r' == (c= getwc(fp)));
	if (c >= 0) ungetwc(c, fp);
	advanceSource();
	continue;
      }
      case '\r': {
	while ('\n' == (c= getwc(fp)));
	ungetwc(c, fp);
	advanceSource();
	continue;
      }
      case '\t':  case ' ': {
	continue;
      }
      case ';': {
	for (;;) {
	  c= getwc(fp);
	  if (EOF == c) break;
	  if ('\n' == c || '\r' == c) {
	    ungetwc(c, fp);
	    break;
	  }
	}
	continue;
      }
      case '"': {
	static struct buffer buf= BUFFER_INITIALISER;
	buffer_reset(&buf);
	for (;;) {
	  c= getwc(fp);
	  if ('"' == c) break;
	  c= readChar(c, fp);
	  if (EOF == c)			fatal("EOF in string literal");
	  buffer_append(&buf, c);
	}
	oop obj= newString(buffer_contents(&buf));
	//buffer_free(&buf);
	return obj;
      }
      case '?': {
	return newLong(readChar(getwc(fp), fp));
      }
      case '\'': {
	oop obj= read(fp);
	if (obj == DONE)
	  obj= s_quote;
	else {
	  GC_PROTECT(obj);
	  obj= newPairFrom(obj, nil, currentSource);
	  obj= newPairFrom(s_quote, obj, currentSource);
	  GC_UNPROTECT(obj);
	}
	return obj;
      }
      case '`': {
	oop obj= read(fp);
	if (obj == DONE)
	  obj= s_quasiquote;
	else {
	  GC_PROTECT(obj);
	  obj= newPairFrom(obj, nil, currentSource);
	  obj= newPairFrom(s_quasiquote, obj, currentSource);
	  GC_UNPROTECT(obj);
	}
	return obj;
      }
      case ',': {
	oop sym= s_unquote;
	c= getwc(fp);
	if ('@' == c)	sym= s_unquote_splicing;
	else		ungetwc(c, fp);
	oop obj= read(fp);
	if (obj == DONE)
	  obj= sym;
	else {
	  GC_PROTECT(obj);
	  obj= newPairFrom(obj, nil, currentSource);
	  obj= newPairFrom(sym, obj, currentSource);
	  GC_UNPROTECT(obj);
	}
	return obj;
      }
      case '0' ... '9':
      doDigits:	{
	static struct buffer buf= BUFFER_INITIALISER;
	buffer_reset(&buf);
	do {
	  buffer_append(&buf, c);
	  c= getwc(fp);
	} while (isDigit10(c));
	if (('.' == c) || ('e' == c)) {
	    if ('.' == c) {
		do {
		    buffer_append(&buf, c);
		    c= getwc(fp);
		} while (isDigit10(c));
	    }
	    if ('e' == c) {
		buffer_append(&buf, c);
		c= getwc(fp);
		if ('-' == c) {
		    buffer_append(&buf, c);
		    c= getwc(fp);
		}
		while (isDigit10(c)) {
		    buffer_append(&buf, c);
		    c= getwc(fp);
		}
	    }
	    ungetwc(c, fp);
	    oop obj=  newDouble(wcstod(buffer_contents(&buf), 0));
	    return obj;
	}
	if (('x' == c) && (1 == buf.position))
	  do {
	    buffer_append(&buf, c);
	    c= getwc(fp);
	  } while (isDigit16(c));
	ungetwc(c, fp);
	oop obj= newLong(wcstoul(buffer_contents(&buf), 0, 0));
	return obj;
      }
      case '(': return readList(fp, ')');      case ')': ungetwc(c, fp);  return DONE;
      case '[': {
	  oop obj= readList(fp, ']');			GC_PROTECT(obj);
	  obj= newPairFrom(s_bracket, obj, obj);	GC_UNPROTECT(obj);
	  return obj;
      }
      case ']': ungetwc(c, fp);  return DONE;
      case '{': {
	  oop obj= readList(fp, '}');			GC_PROTECT(obj);
	  obj= newPairFrom(s_brace, obj, obj);		GC_UNPROTECT(obj);
	  return obj;
      }
      case '}': ungetwc(c, fp);  return DONE;
      case '-': {
	wint_t d= getwc(fp);
	ungetwc(d, fp);
	if (isDigit10(d)) goto doDigits;
	/* fall through... */
      }
      default: {
	if (isLetter(c)) {
	  static struct buffer buf= BUFFER_INITIALISER;
	  oop obj= nil;						GC_PROTECT(obj);
	  //oop in= nil;					GC_PROTECT(in);
	  buffer_reset(&buf);
	  while (isLetter(c) || isDigit10(c)) {
//	    if (('.' == c) && buf.position) {
//	      c= getwc(fp);
//	      if (!isLetter(c) && !isDigit10(c)) {
//		ungetwc(c, fp);
//		c= '.';
//	      }
//	      else {
//		obj= intern(buffer_contents(&buf));
//		in=  newPair(obj, in);
//		buffer_reset(&buf);
//	      }
//	    }
	    buffer_append(&buf, c);
	    c= getwc(fp);
	  }
	  ungetwc(c, fp);
	  obj= intern(buffer_contents(&buf));
//	  while (nil != in) {
//	    obj= newPair(obj, nil);
//	    obj= newPair(getHead(in), obj);
//	    obj= newPair(s_in, obj);
//	    in= getTail(in);
//	  }
	  //GC_UNPROTECT(in);
	  GC_UNPROTECT(obj);
	  return obj;
	}
	fatal(isPrint(c) ? "illegal character: 0x%02x '%c'" : "illegal character: 0x%02x", c, c);
      }
    }
  }
}

static void doprint(FILE *stream, oop obj, int storing)
{
  if (!obj) {
    fprintf(stream, "()");
    return;
  }
  if (obj == get(globals, Variable,value)) {
    fprintf(stream, "<globals>");
    return;
  }
  switch (getType(obj)) {
    case Undefined:	fprintf(stream, "UNDEFINED");		break;
    case Data: {
	//int i, j= GC_size(obj);
	fprintf(stream, "<data[%i]", (int)GC_size(obj));
	//for (i= 0;  i < j;  ++i) fprintf(stream, " %02x", ((unsigned char *)obj)[i]);
	fprintf(stream, ">");
	break;
    }
    case Long:		fprintf(stream, "%ld", getLong(obj));	break;
    case Double:	fprintf(stream, "%lf", getDouble(obj));	break;
    case String: {
      if (!storing)
	fprintf(stream, "%ls", get(obj, String,bits));
      else {
	wchar_t *p= get(obj, String,bits);
	int c;
	putc('"', stream);
	while ((c= *p++)) {
	  if (c >= ' ')
	    switch (c) {
	      case '"':  printf("\\\"");  break;
	      case '\\': printf("\\\\");  break;
	      default:	 putwc(c, stream);  break;
	    }
	  else fprintf(stream, "\\%03o", c);
	}
	putc('"', stream);
      }
      break;
    }
    case Symbol:	fprintf(stream, "%ls", get(obj, Symbol,bits));	break;
    case Pair: {
#if 0
      if (nil != get(obj, Pair,source)) {
	oop source= get(obj, Pair,source);
	oop path= car(source);
	oop line= cdr(source);
	fprintf(stream, "<%ls:%ld>", get(path, String,bits), getLong(line));
      }
#endif
      fprintf(stream, "(");
      for (;;) {
	assert(is(Pair, obj));
#if defined(NDEBUG)
	if (is(Env, getHead(obj))) {
	  obj= getTail(obj);
	  if (!is(Pair, obj)) break;
	  continue;
	}
#endif
	doprint(stream, getHead(obj), storing);
	obj= getTail(obj);
	if (!is(Pair, obj)) break;
	fprintf(stream, " ");
      }
      if (nil != obj) {
	fprintf(stream, " . ");
	doprint(stream, obj, storing);
      }
      fprintf(stream, ")");
      break;
    }
    case Array: {
      int i, len= arrayLength(obj);
      fprintf(stream, "Array<%d>(", arrayLength(obj));
      for (i= 0;  i < len;  ++i) {
	if (i) fprintf(stream, " ");
	doprint(stream, arrayAt(obj, i), storing);
      }
      fprintf(stream, ")");
      break;
    }
    case Expr: {
      fprintf(stream, "Expr");
      if (nil != (get(obj, Expr,name))) {
	fprintf(stream, ".");
	doprint(stream, get(obj, Expr,name), storing);
      }
      fprintf(stream, "=");
      doprint(stream, cadr(get(obj, Expr,defn)), storing);
      break;
    }
    case Form: {
      fprintf(stream, "Form(");
      doprint(stream, get(obj, Form,function), storing);
      fprintf(stream, ", ");
      doprint(stream, get(obj, Form,symbol), storing);
      fprintf(stream, ")");
      break;
    }
    case Fixed: {
      if (isatty(1)) {
	fprintf(stream, "[1m");
	doprint(stream, get(obj, Fixed,function), storing);
	fprintf(stream, "[m");
      }
      else {
	fprintf(stream, "Fixed<");
	doprint(stream, get(obj, Fixed,function), storing);
	fprintf(stream, ">");
      }
      break;
    }
    case Subr: {
      if (get(obj, Subr,name))
	fprintf(stream, "%ls", get(obj, Subr,name));
      else
	fprintf(stream, "Subr<%p>", get(obj, Subr,imp));
      break;
    }
    case Variable: {
      if (!isGlobal(obj) && isatty(1)) fprintf(stream, "[4m");
      doprint(stream, get(obj, Variable,name), 0);
      if (!isGlobal(obj) && isatty(1)) fprintf(stream, "[m");
#if !defined(NDEBUG)
      oop env= get(obj, Variable,env);
      if (nil != env) fprintf(stream, ";%ld+%ld", getLong(get(env, Env,level)), getLong(get(obj, Variable,index)));
#endif
      break;
    }
    case Env: {
      oop level= get(obj, Env,level);
      oop offset= get(obj, Env,offset);
      fprintf(stream, "Env%s%s<%ld+%ld:", ((nil == get(obj, Env,parent)) ? "*" : ""), ((nil == get(obj, Env,stable)) ? "=" : ""),
	      is(Long, level) ? getLong(level) : -1, is(Long, offset) ? getLong(offset) : -1);
#if 0
      oop bnd= get(obj, Env,bindings);
      int idx= arrayLength(bnd);
      while (--idx >= 0) {
	doprint(stream, arrayAt(bnd, idx), storing);
	if (idx) fprintf(stream, " ");
      }
#endif
      fprintf(stream, ">");
      break;
    }
    case Context: {
      fprintf(stream, "Context<");
      doprint(stream, get(obj, Context,env), storing);
      fprintf(stream, "=");
      doprint(stream, get(obj, Context,bindings), storing);
      fprintf(stream, ">");
      break;
    }
    default: {
      oop name= lookup(get(globals, Variable,value), intern(L"%type-names"));
      if (is(Array, name)) {
	name= arrayAt(name, getType(obj));
	if (is(Symbol, name)) {
	  fprintf(stream, "[34m%ls[m", get(name, Symbol,bits));
	  break;
	}
      }
      fprintf(stream, "<type=%i>", getType(obj));
      break;
    }
  }
}

static void print(oop obj)			{ doprint(stdout, obj, 0);  fflush(stdout); }

static void fdump(FILE *stream, oop obj)	{ doprint(stream, obj, 1);  fflush(stream); }
static void dump(oop obj)			{ fdump(stdout, obj); }

static void fdumpln(FILE *stream, oop obj)
{
  fdump(stream, obj);
  fprintf(stream, "\n");
  fflush(stream);
}

static void dumpln(oop obj)			{ fdumpln(stdout, obj); }

static oop apply(oop fun, oop args, oop ctx);

static oop concat(oop head, oop tail)
{
  if (!is(Pair, head)) return tail;
  tail= concat(getTail(head), tail);		GC_PROTECT(tail);
  head= newPairFrom(getHead(head), tail, head);	GC_UNPROTECT(tail);
  return head;
}

static void setSource(oop obj, oop src)
{
  if (!is(Pair, obj)) return;
  if (nil == get(obj, Pair,source)) set(obj, Pair,source, src);
  setSource(getHead(obj), src);
  setSource(getTail(obj), src);
}

static oop exlist(oop obj, oop env);

static oop expand(oop expr, oop env)
{
  if (opt_v > 1) { printf("EXPAND ");  dumpln(expr); }
  if (is(Pair, expr)) {
    oop head= expand(getHead(expr), env);			GC_PROTECT(head);
    if (is(Symbol, head)) {
      oop val= findVariable(env, head);
      if (is(Variable, val)) val= get(val, Variable,value);
      if (is(Form, val) && (nil != get(val, Form,function))) {
	oop args= newPairFrom(env, getTail(expr), expr);	GC_PROTECT(args);
	head= apply(get(val, Form,function), args, nil);	GC_UNPROTECT(args);
	head= expand(head, env);				GC_UNPROTECT(head);
	if (opt_v > 1) { printf("EXPAND => ");  dumpln(head); }
	setSource(head, get(expr, Pair,source));
	return head;
      }
    }
    oop tail= getTail(expr);					GC_PROTECT(tail);
    if (s_quote != head) tail= exlist(tail, env);
    if (s_set == head && is(Pair, car(tail)) && is(Symbol, caar(tail)) /*&& s_in != caar(tail)*/) {
      static struct buffer buf= BUFFER_INITIALISER;
      buffer_reset(&buf);
      buffer_appendAll(&buf, L"set-");
      buffer_appendAll(&buf, get(getHead(getHead(tail)), Symbol,bits));
      head= intern(buffer_contents(&buf));
      tail= concat(getTail(getHead(tail)), getTail(tail));
    }
    expr= newPairFrom(head, tail, expr);			GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  }
  else if (is(Symbol, expr)) {
    oop val= findVariable(env, expr);
    if (is(Variable, val)) val= get(val, Variable,value);
    if (is(Form, val) && (nil != get(val, Form,symbol))) {
      oop args= newPair(expr, nil);			GC_PROTECT(args);
      args= newPair(env, args);
      args= apply(get(val, Form,symbol), args, nil);
      args= expand(args, env);				GC_UNPROTECT(args);
      setSource(args, expr);
      return args;
    }
  }
  else {
    oop fn= arrayAt(get(expanders, Variable,value), getType(expr));
    if (nil != fn) {
      oop args= newPair(expr, nil);		GC_PROTECT(args);
      args= apply(fn, args, nil);		GC_UNPROTECT(args);
      setSource(args, expr);
      return args;
    }
  }
  if (opt_v > 1) { printf("EXPAND => ");  dumpln(expr); }
  return expr;
}

static oop exlist(oop list, oop env)
{
  if (!is(Pair, list)) return expand(list, env);
  oop head= expand(getHead(list), env);			GC_PROTECT(head);
  oop tail= exlist(getTail(list), env);			GC_PROTECT(tail);
  head= newPairFrom(head, tail, list);			GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  return head;
}

static oop enlist(oop obj, oop env);

static void define_bindings(oop bindings, oop innerEnv)
{										GC_PROTECT(bindings);
    while (is(Pair, bindings))
    {
	oop var= getHead(bindings);						GC_PROTECT(var);
	if (!is(Symbol, var)) var= car(var);
	var= define(innerEnv, var, nil);					GC_UNPROTECT(var);
	bindings= getTail(bindings);
    }										GC_UNPROTECT(bindings);
}

static oop encode_bindings(oop expr, oop bindings, oop outerEnv, oop innerEnv)
{
    if (is(Pair, bindings))
    {										GC_PROTECT(bindings);
	oop binding= getHead(bindings);						GC_PROTECT(binding);
	if (is(Symbol, binding))
	    binding= newPairFrom(binding, nil, expr);
	oop var= car(binding);							GC_PROTECT(var);
	oop val= cdr(binding);							GC_PROTECT(val);
	var= findLocalVariable(innerEnv, var);					assert(nil != var);
	val= enlist(val, outerEnv);
	binding= newPairFrom(var, val, expr);					GC_UNPROTECT(val);  GC_UNPROTECT(var);
	oop rest= encode_bindings(expr, getTail(bindings), outerEnv, innerEnv);
	bindings= newPairFrom(binding, rest, expr);				GC_UNPROTECT(binding);
										GC_UNPROTECT(bindings);
    }
    return bindings;
}

static oop encode_let(oop expr, oop tail, oop env)
{
    oop args= car(tail);					GC_PROTECT(tail);  GC_PROTECT(env);
    oop env2= newEnv(env, 0, getLong(get(env, Env,offset)));	GC_PROTECT(env2);
    define_bindings(args, env2);
    set(env, Env,offset, newLong(getLong(get(env2, Env,offset))));
    oop bindings= encode_bindings(expr, args, env, env2);	GC_PROTECT(bindings);
    oop body= cdr(tail);					GC_PROTECT(body);
    body= enlist(body, env2);
    tail= newPairFrom(bindings, body, expr);			GC_UNPROTECT(body);  GC_UNPROTECT(bindings);
    tail= newPairFrom(env2, tail, expr);			GC_UNPROTECT(env2);  GC_UNPROTECT(env);  GC_UNPROTECT(tail);
    return tail;
}

static oop encode(oop expr, oop env)
{
  if (opt_O < 2) arrayAtPut(traceStack, traceDepth++, expr);
  if (opt_v > 1) { printf("ENCODE ");  dumpln(expr); }
  if (is(Pair, expr)) {
    oop head= encode(getHead(expr), env);			GC_PROTECT(head);
    oop tail= getTail(expr);					GC_PROTECT(tail);
    if (f_let == head) { // (let ENV (bindings...) . body)
	tail= encode_let(expr, tail, env);
    }
    else if (f_lambda == head) { // (lambda ENV params . body)
      oop args= car(tail);
      env= newEnv(env, 1, 0);					GC_PROTECT(env);
      while (is(Pair, args)) {
	if (!is(Symbol, getHead(args))) {
	  fprintf(stderr, "\nerror: non-symbol parameter name: ");
	  fdumpln(stderr, getHead(args));
	  fatal(0);
	}
	define(env, getHead(args), nil);
	args= getTail(args);
      }
      if (nil != args) {
	if (!is(Symbol, args)) {
	  fprintf(stderr, "\nerror: non-symbol parameter name: ");
	  fdumpln(stderr, args);
	  fatal(0);
	}
	define(env, args, nil);
      }
      tail= enlist(tail, env);
      tail= newPairFrom(env, tail, expr);			GC_UNPROTECT(env);
    }
    else if (f_define == head) {
      oop var= define(get(globals, Variable,value), car(tail), nil);
      tail= enlist(cdr(tail), env);
      tail= newPairFrom(var, tail, expr);
    }
    else if (f_set == head) {
      oop var= findVariable(env, car(tail));
      if (nil == var) fatal("set: undefined variable: %ls", get(car(tail), Symbol,bits));
      tail= enlist(cdr(tail), env);
      tail= newPairFrom(var, tail, expr);
    }
    else if (f_quote != head)
      tail= enlist(tail, env);
    expr= newPairFrom(head, tail, expr);			GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  }
  else if (is(Symbol, expr)) {
    oop val= findVariable(env, expr);
    if (nil == val) fatal("undefined variable: %ls", get(expr, Symbol,bits));
    expr= val;
    if (isGlobal(expr)) {
      val= get(expr, Variable,value);
      if (is(Form, val) || is(Fixed, val))
	expr= val;
    }
    else {
      oop venv= get(val, Variable,env);
      if (getLong(get(venv, Env,level)) != getLong(get(env, Env,level)))
	set(venv, Env,stable, s_t);
    }
  }
  else {
    oop fn= arrayAt(get(encoders, Variable,value), getType(expr));
    if (nil != fn) {
      oop args= newPair(env, nil);		GC_PROTECT(args);
      args= newPair(expr, args);
      expr= apply(fn, args, nil);		GC_UNPROTECT(args);
    }
  }
  if (opt_v > 1) { printf("ENCODE => ");  dumpln(expr); }
  --traceDepth;
  return expr;
}

static oop enlist(oop list, oop env)
{
  if (!is(Pair, list)) return encode(list, env);
  oop head= encode(getHead(list), env);			GC_PROTECT(head);
  oop tail= enlist(getTail(list), env);			GC_PROTECT(tail);
  head= newPairFrom(head, tail, list);			GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  return head;
}

static oop evlist(oop obj, oop env);

static int fprintSource(FILE *stream, oop exp)
{
    if (is(Pair, exp)) {
	oop src= get(exp, Pair,source);
	if (nil != src) {
	    oop path= car(src);
	    oop line= cdr(src);
	    if (is(String, path) && is(Long, line)) {
		return fprintf(stream, "%ls:%ld", get(path, String,bits), getLong(line));
	    }
	}
    }
    return 0;
}

static int printSource(oop exp)
{
    return fprintSource(stdout, exp);
}

static void fatal(char *reason, ...)
{
  if (reason) {
    va_list ap;
    va_start(ap, reason);
    fprintf(stderr, "\nerror: ");
    vfprintf(stderr, reason, ap);
    fprintf(stderr, "\n");
    va_end(ap);
  }

  oop tracer= get(backtrace, Variable,value);

  if (nil != tracer) {
    oop args= newLong(traceDepth);		GC_PROTECT(args);
    args= newPair(args, nil);
    args= newPair(traceStack, args);
    apply(tracer, args, nil);			GC_UNPROTECT(args);
  }
  else {
      if (traceDepth) {
	  int i= traceDepth;
	  int j= 12;
	  while (i-- > 0) {
	      //printf("%3d: ", i);
	      oop exp= arrayAt(traceStack, i);
	      printf("[32m[?7l");
	      int l= printSource(exp);
	      if (l >= j) j= l;
	      if (!l) while (l < 3) l++, putchar('.');
	      while (l++ < j) putchar(' ');
	      printf("[0m ");
	      dumpln(arrayAt(traceStack, i));
	      printf("[?7h");
	  }
      }
      else {
	  printf("no backtrace\n");
      }
  }
  exit(1);
}

static oop eval(oop obj, oop ctx)
{
  if (opt_v > 2) { printf("EVAL ");  dump(obj); printf(" IN ");  dumpln(ctx); }
  switch (getType(obj)) {
    case Undefined:
    case Long:
    case Double:
    case String: {
      return obj;
    }
    case Pair: {
      if (opt_O < 2) arrayAtPut(traceStack, traceDepth++, obj);
      oop head= eval(getHead(obj), ctx);		GC_PROTECT(head);
      if (is(Fixed, head))
	head= apply(get(head, Fixed,function), getTail(obj), ctx);
      else  {
	oop args= evlist(getTail(obj), ctx);		GC_PROTECT(args);
	if (opt_g) arrayAtPut(traceStack, traceDepth++, newPair(head, args));
	head= apply(head, args, ctx);			GC_UNPROTECT(args);
	if (opt_g) --traceDepth;
      }							GC_UNPROTECT(head);
      --traceDepth;
      return head;
    }
    case Variable: {
      if (isGlobal(obj)) return get(obj, Variable,value);
      int delta= getLong(get(get(ctx, Context,env), Env,level)) - getLong(get(get(obj, Variable,env), Env,level));
      oop cx= ctx;
      while (delta--) cx= get(cx, Context,home);
      return arrayAt(get(cx, Context,bindings), getLong(get(obj, Variable,index)));
    }
    default: {
      if (opt_g) arrayAtPut(traceStack, traceDepth++, obj);
      oop ev= arrayAt(get(evaluators, Variable,value), getType(obj));
      if (nil != ev) {
	oop args= newPair(obj, nil);			GC_PROTECT(args);
	obj= apply(ev, args, ctx);			GC_UNPROTECT(args);
      }
      if (opt_g) --traceDepth;
      return obj;
    }
  }
  return nil;
}

static oop evlist(oop obj, oop ctx)
{
  if (!is(Pair, obj)) return obj;
  oop head= eval(getHead(obj), ctx);		GC_PROTECT(head);
  oop tail= evlist(getTail(obj), ctx);		GC_PROTECT(tail);
  //head= newPairFrom(head, tail, obj);		GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  head= newPair(head, tail);			GC_UNPROTECT(tail);  GC_UNPROTECT(head);
  return head;
}

static oop apply(oop fun, oop arguments, oop ctx)
{
  if (opt_v > 2) { printf("APPLY ");  dump(fun);  printf(" TO ");  dump(arguments);  printf(" IN ");  dumpln(ctx); }
  switch (getType(fun)) {
    case Expr: {
      if (opt_p) arrayAtPut(traceStack, traceDepth++, fun);
      oop args=    arguments;
      oop defn=    get(fun, Expr,defn);				GC_PROTECT(defn);
      oop env=     car(defn);
      oop formals= cadr(defn);
      ctx=         newContext(get(fun, Expr,ctx), ctx, env);	GC_PROTECT(ctx);
      oop locals=  get(ctx, Context,bindings);
      //oop tmp=     nil;					GC_PROTECT(tmp);
      while (is(Pair, formals)) {
	if (!is(Pair, args)) {
	  fprintf(stderr, "\nerror: too few arguments applying ");
	  fdump(stderr, fun);
	  fprintf(stderr, " to ");
	  fdumpln(stderr, arguments);
	  fatal(0);
	}
	arrayAtPut(locals, getLong(get(getHead(formals), Variable,index)), getHead(args));
	formals= getTail(formals); // xxx formals should be in env with fixed argument arity in defn
	args= getTail(args); // xxx args should be set up in the callee context
      }
      if (is(Variable, formals)) {
	arrayAtPut(locals, getLong(get(formals, Variable,index)), args);
	args= nil;
      }
      if (nil != args) {
	fprintf(stderr, "\nerror: too many arguments applying ");
	fdump(stderr, fun);
	fprintf(stderr, " to ");
	fdumpln(stderr, arguments);
	fatal(0);
      }
      oop ans= nil;
      oop body= cddr(defn);
      if (opt_g) arrayAtPut(traceStack, traceDepth++, body);
      while (is(Pair, body)) {
	if (opt_g) arrayAtPut(traceStack, traceDepth - 1, getHead(body));
	set(ctx, Context,pc, body);
	ans= eval(getHead(body), ctx);
	body= getTail(body);
      }
      if (opt_g || opt_p) --traceDepth;
      //GC_UNPROTECT(tmp);
      GC_UNPROTECT(ctx);
      GC_UNPROTECT(defn);
      if (nil != get(env, Env,stable))	set(ctx, Context,callee, nil);
      return ans;
    }
    case Fixed: {
      return apply(get(fun, Fixed,function), arguments, ctx);
    }
    case Subr: {
	if (opt_p) arrayAtPut(traceStack, traceDepth++, fun);
	oop ans= get(fun, Subr,imp)(arguments, ctx);
	if (opt_p) --traceDepth;
	return ans;
    }
    default: {
      oop args= arguments;
      oop ap= arrayAt(get(applicators, Variable,value), getType(fun));
      if (nil != ap) {						GC_PROTECT(args);
	if (opt_g) arrayAtPut(traceStack, traceDepth++, fun);
	args= newPair(fun, args);
	args= apply(ap, args, ctx);				GC_UNPROTECT(args);
	if (opt_g) --traceDepth;
	return args;
      }
      fprintf(stderr, "\nerror: cannot apply: ");
      fdumpln(stderr, fun);
      fatal(0);
    }
  }
  return nil;
}

static int length(oop list)
{
  if (!is(Pair, list)) return 0;
  return 1 + length(getTail(list));
}

static void arity(oop args, char *name)
{
  fatal("wrong number of arguments (%i) in: %s\n", length(args), name);
}

static void arity1(oop args, char *name)
{
  if (!is(Pair, args) || is(Pair, getTail(args))) arity(args, name);
}

static void arity2(oop args, char *name)
{
  if (!is(Pair, args) || !is(Pair, getTail(args)) || is(Pair, getTail(getTail(args)))) arity(args, name);
}

static void arity3(oop args, char *name)
{
  if (!is(Pair, args) || !is(Pair, getTail(args)) || !is(Pair, getTail(getTail(args))) || is(Pair, getTail(getTail(getTail(args))))) arity(args, name);
}

#define subr(NAME)	oop subr_##NAME(oop args, oop ctx)

static subr(if)
{
  if (nil != eval(car(args), ctx))
    return eval(cadr(args), ctx);
  oop ans= nil;
  args= cddr(args);
  while (is(Pair, args)) {
    ans= eval(getHead(args), ctx);
    args= cdr(args);
  }
  return ans;
}

static subr(and)
{
  oop ans= s_t;
  for (;  is(Pair, args);  args= getTail(args))
    if (nil == (ans= eval(getHead(args), ctx)))
      break;
  return ans;
}

static subr(or)
{
  oop ans= nil;
  for (;  is(Pair, args);  args= getTail(args))
    if (nil != (ans= eval(getHead(args), ctx)))
      break;
  return ans;
}

static subr(set)
{
  oop var= car(args);
  if (!is(Variable, var)) {
    fprintf(stderr, "\nerror: cannot set undefined variable: ");
    fdumpln(stderr, var);
    fatal(0);
  }
  oop val= eval(cadr(args), ctx);
  if (is(Expr, val) && (nil == get(val, Expr,name))) set(val, Expr,name, get(var, Variable,name));
  if (isGlobal(var)) return set(var, Variable,value, val);
  int delta= getLong(get(get(ctx, Context,env), Env,level)) - getLong(get(get(var, Variable,env), Env,level));
  oop cx= ctx;
  while (delta--) cx= get(cx, Context,home);
  return arrayAtPut(get(cx, Context,bindings), getLong(get(var, Variable,index)), val);
}

static subr(let)
{
  oop tmp=  nil;		GC_PROTECT(tmp);
  oop bindings= cadr(args);
  oop body= cddr(args);
  oop locals= get(ctx, Context,bindings);
  while (is(Pair, bindings)) {
    oop binding= getHead(bindings);
    if (is(Pair, binding)) {
      oop var=    getHead(binding);
      oop prog=   getTail(binding);
      while (is(Pair, prog)) {
	oop value= getHead(prog);
	tmp= eval(value, ctx);
	prog= getTail(prog);
      }
      arrayAtPut(locals, getLong(get(var, Variable,index)), tmp);
    }
    bindings= getTail(bindings);
  }
  oop ans= nil;			GC_UNPROTECT(tmp);
  while (is(Pair, body)) {
    ans= eval(getHead(body), ctx);
    body= getTail(body);
  }
  return ans;
}

static subr(while)
{
  oop tst= car(args);
  while (nil != eval(tst, ctx)) {
    oop body= cdr(args);
    while (is(Pair, body)) {
      eval(getHead(body), ctx);
      body= getTail(body);
    }
  }
  return nil;
}

static subr(quote)
{
  return car(args);
}

static subr(lambda)
{
  return newExpr(args, ctx);
}

static subr(define)
{
  oop var= car(args);
  if (!is(Variable, var)) {
    fprintf(stderr, "\nerror: non-variable in define: ");
    fdumpln(stderr, var);
    fatal(0);
  }
  oop value= eval(cadr(args), ctx);
  set(var, Variable,value, value);
  oop expr= value;
  if (is(Form, expr)) expr= get(value, Form,function);
  if (is(Expr, expr) && (nil == get(expr, Expr,name))) set(expr, Expr,name, get(var, Variable,name));
  return value;
}

static subr(definedP)
{
  oop symbol= car(args);
  oop theenv= cadr(args);
  if (nil == theenv) theenv= get(globals, Variable,value);
  return findVariable(theenv, symbol);
}

#define _do_unary()				\
  _do(com, ~)

#define _do(NAME, OP)								\
  static subr(NAME)								\
  {										\
    arity1(args, #OP);								\
    oop rhs= getHead(args);							\
    if (isLong(rhs)) return newLong(OP getLong(rhs));				\
    fprintf(stderr, "%s: non-integer argument: ", #OP);				\
    fdumpln(stderr, rhs);							\
    fatal(0);									\
    return nil;									\
  }

_do_unary()

#undef _do

#define _do_ibinary()								\
  _do(bitand,  &)  _do(bitor,   |)  _do(bitxor,  ^)  _do(shl, <<)  _do(shr, >>)

#define _do(NAME, OP)								\
  static subr(NAME)								\
  {										\
    arity2(args, #OP);								\
    oop lhs= getHead(args);							\
    oop rhs= getHead(getTail(args));						\
    if (isLong(lhs) && isLong(rhs))						\
      return newLong(getLong(lhs) OP getLong(rhs));				\
    fprintf(stderr, "%s: non-integer argument: ", #OP);				\
    if (!isLong(lhs))	fdumpln(stderr, lhs);					\
    else		fdumpln(stderr, rhs);					\
    fatal(0);									\
    return nil;									\
    }

_do_ibinary()

#undef _do

#define _do_binary()								\
  _do(add,     +)  _do(mul,     *)  _do(div,     /)

#define _do(NAME, OP)										\
    static subr(NAME)										\
    {												\
	arity2(args, #OP);									\
	oop lhs= getHead(args);									\
	oop rhs= getHead(getTail(args));							\
	if (isLong(lhs)) {									\
	    if (isLong(rhs))	return newLong(getLong(lhs) OP getLong(rhs));			\
	    if (isDouble(rhs))	return newDouble((double)getLong(lhs) OP getDouble(rhs));	\
	}											\
	else if (isDouble(lhs)) {								\
	    if (isDouble(rhs))	return newDouble(getDouble(lhs) OP getDouble(rhs));		\
	    if (isLong(rhs))	return newDouble(getDouble(lhs) OP (double)getLong(rhs));	\
	}											\
	fprintf(stderr, "%s: non-numeric argument: ", #OP);					\
	if (!isNumeric(lhs))	fdumpln(stderr, lhs);						\
	else			fdumpln(stderr, rhs);						\
	fatal(0);										\
	return nil;										\
    }

_do_binary()

#undef _do

static subr(sub)
{
    if (!is(Pair, args)) arity(args, "-");
    oop lhs= getHead(args);  args= getTail(args);
    if (!is(Pair, args)) {
	if (isLong  (lhs))	return newLong  (- getLong  (lhs));
	if (isDouble(lhs))	return newDouble(- getDouble(lhs));
	fprintf(stderr, "-: non-numeric argument: ");
	fdumpln(stderr, lhs);
	fatal(0);
    }
    oop rhs= getHead(args);  args= getTail(args);
    if (is(Pair, args)) arity(args, "-");
    if (isLong(lhs)) {
	if (isLong(rhs))	return newLong(getLong(lhs) - getLong(rhs));
	if (isDouble(rhs))	return newDouble((double)getLong(lhs) - getDouble(rhs));
    }
    if (isDouble(lhs)) {
	if (isDouble(rhs))	return newDouble(getDouble(lhs) - getDouble(rhs));
	if (isLong(rhs))	return newDouble(getDouble(lhs) - (double)getLong(rhs));
	lhs= rhs; // for error msg
    }
    fprintf(stderr, "-: non-numeric argument: ");
    fdumpln(stderr, lhs);
    fatal(0);
    return nil;
}

static subr(mod)
{
    if (!is(Pair, args)) arity(args, "%");
    oop lhs= getHead(args);  args= getTail(args);
    if (!is(Pair, args)) arity(args, "%");
    oop rhs= getHead(args);  args= getTail(args);
    if (is(Pair, args)) arity(args, "%");
    if (isLong(lhs)) {
	if (isLong(rhs))	return newLong(getLong(lhs) % getLong(rhs));
	if (isDouble(rhs))	return newDouble(fmod((double)getLong(lhs), getDouble(rhs)));
    }
    else if (isDouble(lhs)) {
	if (isDouble(rhs))	return newDouble(fmod(getDouble(lhs), getDouble(rhs)));
	if (isLong(rhs))	return newDouble(fmod(getDouble(lhs), (double)getLong(rhs)));
    }
    fprintf(stderr, "%%: non-numeric argument: ");
    if (!isNumeric(lhs))	fdumpln(stderr, lhs);
    else			fdumpln(stderr, rhs);
    fatal(0);
    return nil;
}

#define _do_relation()									\
  _do(lt,   <)  _do(le,  <=)  _do(ge,  >=)  _do(gt,   >)

#define _do(NAME, OP)										\
    static subr(NAME)										\
    {												\
	arity2(args, #OP);									\
	oop lhs= getHead(args);									\
	oop rhs= getHead(getTail(args));							\
	if (isLong(lhs)) {									\
	    if (isLong(rhs))	return newBool(getLong(lhs) OP getLong(rhs));			\
	    if (isDouble(rhs))	return newBool((double)getLong(lhs) OP getDouble(rhs));		\
            lhs= rhs;										\
	}											\
	else if (isDouble(lhs)) {								\
	    if (isDouble(rhs))	return newBool(getDouble(lhs) OP getDouble(rhs));		\
	    if (isLong(rhs))	return newBool(getDouble(lhs) OP (double)getLong(rhs));		\
	    lhs= rhs;										\
	}											\
	fprintf(stderr, "%s: non-numeric argument: ", #OP);					\
	fdumpln(stderr, lhs);									\
	fatal(0);										\
	return nil;										\
    }

_do_relation()

#undef _do

static int equal(oop lhs, oop rhs)
{
    int ans= 0;
    switch (getType(lhs)) {
	case Long:
	    switch (getType(rhs)) {
		case Long:	ans= (        getLong  (lhs) ==         getLong  (rhs));	break;
		case Double:	ans= ((double)getLong  (lhs) ==         getDouble(rhs));	break;
	    }
	    break;
	case Double:
	    switch (getType(rhs)) {
		case Long:	ans= (        getDouble(lhs) == (double)getLong  (rhs));	break;
		case Double:	ans= (        getDouble(lhs) ==         getDouble(rhs));	break;
	    }
	    break;
	case String:		ans= (is(String, rhs) 	&& !wcscmp(get(lhs, String,bits), get(rhs, String,bits)));	break;
	default:		ans= (lhs == rhs);									break;
    }
    return ans;
}

static subr(eq)
{
    arity2(args, "=");
    oop lhs= getHead(args);
    oop rhs= getHead(getTail(args));
    return newBool(equal(lhs, rhs));
}

static subr(ne)
{
    arity2(args, "!=");
    oop lhs= getHead(args);
    oop rhs= getHead(getTail(args));
    return newBool(!equal(lhs, rhs));
}

#if !defined(WIN32) && (!LIB_GC)
static void profilingDisable(int);
#endif

static subr(exit)
{
  oop n= car(args);
#if !defined(WIN32) && (!LIB_GC)
  if (opt_p)
  {
      profilingDisable(1);
  }
#endif
  exit(isLong(n) ? getLong(n) : 0);
}

static subr(abort)
{
  fatal(0);
  return nil;
}

static subr(open)
{
  oop arg= car(args);
  if (!is(String, arg)) { fprintf(stderr, "open: non-string argument: ");  fdumpln(stderr, arg);  fatal(0); }
  char *name= strdup(wcs2mbs(get(arg, String,bits)));
  char *mode= "r";
  long  wide= 1;
  if (is(String, cadr(args))) mode= wcs2mbs(get(cadr(args), String,bits));
  if (is(Long, caddr(args))) wide= getLong(caddr(args));
  FILE *stream= (FILE *)fopen(name, mode);
  free(name);
  if (stream) fwide(stream, wide);
  return stream ? newLong((long)stream) : nil;
}

static subr(close)
{
  oop arg= car(args);
  if (!isLong(arg)) { fprintf(stderr, "close: non-integer argument: ");  fdumpln(stderr, arg);  fatal(0); }
  fclose((FILE *)getLong(arg));
  return arg;
}

static subr(getb)
{
  oop arg= car(args);
  if (nil == arg) arg= get(input, Variable,value);
  if (!isLong(arg)) { fprintf(stderr, "getb: non-integer argument: ");  fdumpln(stderr, arg);  fatal(0); }
  FILE *stream= (FILE *)getLong(arg);
  int c= getc(stream);
  return (EOF == c) ? nil : newLong(c);
}

static subr(getc)
{
  oop arg= car(args);
  if (nil == arg) arg= get(input, Variable,value);
  if (!isLong(arg)) { fprintf(stderr, "getc: non-integer argument: ");  fdumpln(stderr, arg);  fatal(0); }
  FILE *stream= (FILE *)getLong(arg);
  int c= getwc(stream);
  return (WEOF == c) ? nil : newLong(c);
}

static subr(putb)
{
  oop chr= car(args);
  oop arg= cadr(args);
  if (nil == arg) arg= get(output, Variable,value);
  if (!isLong(chr)) { fprintf(stderr, "putb: non-integer character: ");  fdumpln(stderr, chr);  fatal(0); }
  if (!isLong(arg)) { fprintf(stderr, "putb: non-integer argument: ");  fdumpln(stderr, arg);  fatal(0); }
  FILE *stream= (FILE *)getLong(arg);
  int c= putc(getLong(chr), stream);
  return (EOF == c) ? nil : chr;
}

static subr(putc)
{
  oop chr= car(args);
  oop arg= cadr(args);
  if (nil == arg) arg= get(output, Variable,value);
  if (!isLong(chr)) { fprintf(stderr, "putc: non-integer character: ");  fdumpln(stderr, chr);  fatal(0); }
  if (!isLong(arg)) { fprintf(stderr, "putc: non-integer argument: ");  fdumpln(stderr, arg);  fatal(0); }
  FILE *stream= (FILE *)getLong(arg);
  int c= putwc(getLong(chr), stream);
  return (WEOF == c) ? nil : chr;
}

static subr(read)
{
  FILE *stream= stdin;
  if (nil == args) {
    beginSource(L"<stdin>");
    oop obj= read(stdin);
    endSource();
    if (obj == DONE) obj= nil;
    return obj;
  }
  oop arg= car(args);			if (!is(String, arg)) { fprintf(stderr, "read: non-String argument: ");  fdumpln(stderr, arg);  fatal(0); }
  wchar_t *path= get(arg, String,bits);
  stream= fopen(wcs2mbs(path), "r");
  if (!stream) return nil;
  fwide(stream, 1);
  beginSource(path);
  oop head= newPairFrom(nil, nil, currentSource), tail= head;	GC_PROTECT(head);
  oop obj= nil;							GC_PROTECT(obj);
  for (;;) {
    obj= read(stream);
    if (obj == DONE) break;
    tail= setTail(tail, newPairFrom(obj, nil, currentSource));
    if (stdin == stream) break;
  }
  head= getTail(head);				GC_UNPROTECT(obj);
  fclose(stream);				GC_UNPROTECT(head);
  endSource();
  return head;
}

static subr(expand)
{
  oop x= car(args);  args= cdr(args);		GC_PROTECT(x);
  oop e= car(args);
  if (nil == e) e= get(ctx, Context,env);
  x= expand(x, e);				GC_UNPROTECT(x);
  return x;
}

static subr(encode)
{
  oop x= car(args);  args= cdr(args);		GC_PROTECT(x);
  oop e= car(args);
  if (nil == e) e= get(ctx, Context,env);
  x= encode(x, e);				GC_UNPROTECT(x);
  return x;
}

static subr(eval)
{
  oop x= car(args);  args= cdr(args);				GC_PROTECT(x);
  oop e= car(args);
  if (nil == e) e= newEnv(get(globals, Variable,value), 1, 0);	GC_PROTECT(e);
  x= expand(x, e);
  x= encode(x, e);
  oop c= newBaseContext(nil, nil, e);				GC_PROTECT(c);
  x= eval  (x, c);						GC_UNPROTECT(c);  GC_UNPROTECT(e);  GC_UNPROTECT(x);
  return x;
}

static subr(apply)
{
    if (!is(Pair, args))					fatal("too few arguments in: apply");
    oop f= car(args);
    oop a= args;						assert(is(Pair, a));
    oop b= getTail(a);
    oop c= cdr(b);
    while (is(Pair, c)) a= b, c= cdr(b= c);			assert(is(Pair, a));
    setTail(a, car(b));
    return apply(f, cdr(args), ctx);
}

static subr(type_of)
{
  arity1(args, "type-of");
  return newLong(getType(getHead(args)));
}

static subr(warn)
{
  while (is(Pair, args)) {
    doprint(stderr, getHead(args), 0);
    args= getTail(args);
  }
  return nil;
}

static subr(print)
{
  while (is(Pair, args)) {
    print(getHead(args));
    args= getTail(args);
  }
  return nil;
}

static subr(dump)
{
  while (is(Pair, args)) {
    dump(getHead(args));
    args= getTail(args);
  }
  return nil;
}

static subr(format)
{
  arity2(args, "format");
  oop     ofmt= car(args);		if (!is(String, ofmt)) fatal("format is not a string");
  oop     oarg= cadr(args);
  wchar_t *fmt= get(ofmt, String,bits);
  void    *arg= 0;
  switch (getType(oarg)) {
    case Undefined:						break;
    case Long:		arg= (void *)getLong(oarg);		break;
	//case Double:	arg= (void *)getDouble(oarg);		break;
    case String:	arg= (void *)get(oarg, String,bits);	break;
    case Symbol:	arg= (void *)get(oarg, Symbol,bits);	break;
    default:		arg= (void *)oarg;			break;
  }
  size_t size= 100;
  wchar_t *p, *np;
  oop ans= nil;
  if (!(p= malloc(sizeof(wchar_t) * size))) return nil;
  for (;;) {
    int n= swnprintf(p, size, fmt, arg);
    if (0 <= n && n < size) {
      ans= newString(p);
      free(p);
      break;
    }
    if (n < 0 && errno == EILSEQ) return nil;
    if (n >= 0)	size= n + 1;
    else	size *= 2;
    if (!(np= realloc(p, sizeof(wchar_t) * size))) {
      free(p);
      break;
    }
    p= np;
  }
  return ans;
}

static subr(form)
{
  return newForm(car(args), cadr(args));
}

static subr(fixedP)
{
  arity1(args, "fixed?");
  return newBool(is(Fixed, getHead(args)));
}

static subr(cons)
{
  oop lhs= car(args);
  oop rhs= cadr(args);
  return newPair(lhs, rhs);	// (is(Pair, rhs) ? newPairFrom(lhs, rhs, rhs) : newPair(lhs, rhs));
}

static subr(pairP)
{
  arity1(args, "pair?");
  return newBool(is(Pair, getHead(args)));
}

static subr(car)
{
  arity1(args, "car");
  return car(getHead(args));
}

static subr(set_car)
{
  arity2(args, "set-car");
  oop arg= getHead(args);				if (!is(Pair, arg)) return nil;
  return setHead(arg, getHead(getTail(args)));
}

static subr(cdr)
{
  arity1(args, "cdr");
  return cdr(getHead(args));
}

static subr(set_cdr)
{
  arity2(args, "set-cdr");
  oop arg= getHead(args);				if (!is(Pair, arg)) return nil;
  return setTail(arg, getHead(getTail(args)));
}

static subr(formP)
{
  arity1(args, "form?");
  return newBool(is(Form, getHead(args)));
}

static subr(symbolP)
{
  arity1(args, "symbol?");
  return newBool(is(Symbol, getHead(args)));
}

static subr(stringP)
{
  arity1(args, "string?");
  return newBool(is(String, getHead(args)));
}

static subr(string)
{
  oop arg= car(args);
  int num= isLong(arg) ? getLong(arg) : 0;
  return _newString(num);
}

static subr(string_length)
{
  arity1(args, "string-length");
  oop arg= getHead(args);		if (!is(String, arg)) { fprintf(stderr, "string-length: non-String argument: ");  fdumpln(stderr, arg);  fatal(0); }
  return newLong(stringLength(arg));
}

static subr(string_at)
{
  arity2(args, "string-at");
  oop arr= getHead(args);		if (!is(String, arr)) { fprintf(stderr, "string-at: non-String argument: ");  fdumpln(stderr, arr);  fatal(0); }
  oop arg= getHead(getTail(args));	if (!isLong(arg)) return nil;
  int idx= getLong(arg);
  if (0 <= idx && idx < stringLength(arr)) return newLong(get(arr, String,bits)[idx]);
  return nil;
}

static subr(set_string_at)
{
  arity3(args, "set-string-at");
  oop arr= getHead(args);			if (!is(String, arr)) { fprintf(stderr, "set-string-at: non-string argument: ");  fdumpln(stderr, arr);  fatal(0); }
  oop arg= getHead(getTail(args));		if (!isLong(arg)) { fprintf(stderr, "set-string-at: non-integer index: ");  fdumpln(stderr, arg);  fatal(0); }
  oop val= getHead(getTail(getTail(args)));	if (!isLong(val)) { fprintf(stderr, "set-string-at: non-integer value: ");  fdumpln(stderr, val);  fatal(0); }
  int idx= getLong(arg);
  if (idx < 0) return nil;
  int len= stringLength(arr);
  if (len <= idx) {
    if (len < 2) len= 2;
    while (len <= idx) len *= 2;
    set(arr, String,bits, (wchar_t *)GC_realloc(get(arr, String,bits), sizeof(wchar_t) * (len + 1)));
    set(arr, String,size, newLong(len));
  }
  get(arr, String,bits)[idx]= getLong(val);
  return val;
}

static subr(string_copy)	// string from len
{
  oop str= car(args);			if (!is(String, str)) { fprintf(stderr, "string-copy: non-string argument: ");  fdumpln(stderr, str);  fatal(0); }
  int ifr= 0;
  int sln= stringLength(str);
  oop ofr= cadr(args);
  if (nil != ofr) {			if (!isLong(ofr)) { fprintf(stderr, "string-copy: non-integer start: ");  fdumpln(stderr, ofr);  fatal(0); }
      ifr= getLong(ofr);
      if (ifr < 0  ) ifr= 0;
      if (ifr > sln) ifr= sln;		assert(ifr >= 0 && ifr <= sln);
      sln -= ifr;			assert(sln >= 0);
  }
  oop oln= caddr(args);
  if (nil != oln) {			if (!isLong(oln)) { fprintf(stderr, "string-copy: non-integer length: ");  fdumpln(stderr, oln);  fatal(0); }
      int iln= getLong(oln);
      if (iln < 0) iln= 0;
      if (iln > sln) iln= sln;		assert(iln >= 0 && ifr + iln <= sln);
      sln= iln;
  }
  return newStringN(get(str, String,bits) + ifr, sln);
}

static subr(string_compare)	// string substring offset=0 length=strlen(substring)
{
  oop str= car(args);			if (!is(String, str)) { fprintf(stderr, "string-compare: non-string argument: ");  fdumpln(stderr, str);  fatal(0); }
  oop arg= cadr(args);			if (!is(String, arg)) { fprintf(stderr, "string-compare: non-string argument: ");  fdumpln(stderr, arg);  fatal(0); }
  oop oof= caddr(args);
  int off= 0;
  if (nil != oof) {			if (!isLong(oof)) { fprintf(stderr, "string-compare: non-integer offset: ");  fdumpln(stderr, oof);  fatal(0); }
      off= getLong(oof);
  }
  oop oln= cadddr(args);
  int len= stringLength(str);
  if (nil != oln) {			if (!isLong(oln)) { fprintf(stderr, "string-compare: non-integer length: ");  fdumpln(stderr, oln);  fatal(0); }
      len= getLong(oln);
  }
  if (off < 0 || len < 0) return newLong(-1);
  if (off >= stringLength(str)) return newLong(-1);
  return newLong(wcsncmp(get(str, String,bits) + off, get(arg, String,bits), len));
}

static subr(symbol_compare)
{
  arity2(args, "symbol-compare");
  oop str= getHead(args);			if (!is(Symbol, str)) { fprintf(stderr, "symbol-compare: non-symbol argument: ");  fdumpln(stderr, str);  fatal(0); }
  oop arg= getHead(getTail(args));		if (!is(Symbol, arg)) { fprintf(stderr, "symbol-compare: non-symbol argument: ");  fdumpln(stderr, arg);  fatal(0); }
  return newLong(wcscmp(get(str, Symbol,bits), get(arg, Symbol,bits)));
}

static subr(string_symbol)
{
  oop arg= car(args);				if (is(Symbol, arg)) return arg;  if (!is(String, arg)) return nil;
  return intern(get(arg, String,bits));
}

static subr(symbol_string)
{
  oop arg= car(args);				if (is(String, arg)) return arg;  if (!is(Symbol, arg)) return nil;
  return newString(get(arg, Symbol,bits));
}

static subr(long_double)
{
  oop arg= car(args);				if (is(Double, arg)) return arg;  if (!isLong(arg)) return nil;
  return newDouble(getLong(arg));
}

static subr(long_string)
{
  oop arg= car(args);				if (is(String, arg)) return arg;  if (!isLong(arg)) return nil;
  wchar_t buf[32];
  swnprintf(buf, 32, L"%ld", getLong(arg));
  return newString(buf);
}

static subr(string_long)
{
    oop arg= car(args);				if (isLong(arg)) return arg;  if (!is(String, arg)) return nil;
    return newLong(wcstol(get(arg, String,bits), 0, 0));
}

static subr(double_long)
{
  oop arg= car(args);				if (isLong(arg)) return arg;  if (!isDouble(arg)) return nil;
  return newLong((long)getDouble(arg));
}

static subr(double_string)
{
    oop arg= car(args);				if (is(String, arg)) return arg;  if (!isDouble(arg)) return nil;
    wchar_t buf[32];
    swnprintf(buf, 32, L"%f", getDouble(arg));
    return newString(buf);
}

static subr(string_double)
{
    oop arg= car(args);				if (is(Double, arg)) return arg;  if (!is(String, arg)) return nil;
    return newDouble(wcstod(get(arg, String,bits), 0));
}

static subr(array)
{
  oop arg= car(args);
  int num= isLong(arg) ? getLong(arg) : 0;
  return newArray(num);
}

static subr(arrayP)
{
  return is(Array, car(args)) ? s_t : nil;
}

static subr(array_length)
{
  arity1(args, "array-length");
  oop arg= getHead(args);		if (!is(Array, arg)) { fprintf(stderr, "array-length: non-Array argument: ");  fdumpln(stderr, arg);  fatal(0); }
  return get(arg, Array,size);
}

static subr(array_at)
{
  arity2(args, "array-at");
  oop arr= getHead(args);
  oop arg= getHead(getTail(args));	if (!isLong(arg)) return nil;
  return arrayAt(arr, getLong(arg));
}

static subr(set_array_at)
{
  arity3(args, "set-array-at");
  oop arr= getHead(args);
  oop arg= getHead(getTail(args));		if (!isLong(arg)) return nil;
  oop val= getHead(getTail(getTail(args)));
  return arrayAtPut(arr, getLong(arg), val);
}

static subr(array_compare)	// array subarray offset=0 length=arrlen(subarray)
{
  oop arr= car(args);			if (!is(Array, arr)) { fprintf(stderr, "array-compare: non-array argument: ");  fdumpln(stderr, arr);  fatal(0); }
  oop brr= cadr(args);			if (!is(Array, brr)) { fprintf(stderr, "array-compare: non-array argument: ");  fdumpln(stderr, brr);  fatal(0); }
  int off= 0;
  int len= 0;
  int aln= arrayLength(arr);
  int bln= arrayLength(brr);
  oop oof= caddr(args);
  if (nil != oof) {			if (!isLong(oof)) { fprintf(stderr, "array-compare: non-integer offset: ");  fdumpln(stderr, oof);  fatal(0); }
      off= getLong(oof);
      if (off < 0) off += aln;
      if (off < 0 || off >= aln)	return newLong(-1);
  }
  oop oln= cadddr(args);
  if (nil != oln) {			if (!isLong(oln)) { fprintf(stderr, "array-compare: non-integer length: ");  fdumpln(stderr, oln);  fatal(0); }
      len= getLong(oln);
      if (len < 0 || len > bln
	  || off + len >= aln)		return newLong(-1);
  }
  else {
      len= arrayLength(arr) - off;
  }
  long *aptr= (long *)get(arr, Array,_array) + off;
  long *bptr= (long *)get(brr, Array,_array);
  long  cmp = 0;
  while (!cmp && len--) cmp= *aptr++ - *bptr++;
  return newLong(cmp);
}

static subr(data)
{
    oop arg= car(args);
    int num= isLong(arg) ? getLong(arg) : 0;
    return newData(num);
}

static subr(data_length)
{
  arity1(args, "data-length");
  oop arg= getHead(args);		if (!is(Data, arg)) { fprintf(stderr, "data-length: non-Data argument: ");  fdumpln(stderr, arg);  fatal(0); }
  return newLong(GC_size(arg));
}

#define accessor(name, type)										\
    static subr(name##_at)										\
    {													\
	arity2(args, #name"-at");									\
	oop obj= getHead(args);										\
	oop arg= getHead(getTail(args));		if (!isLong(arg)) return nil;			\
	int idx= getLong(arg);										\
	if (is(Long, obj))										\
	    return newLong(((type *)getLong(obj))[idx]);						\
	if ((unsigned)idx >= (unsigned)GC_size(obj) / sizeof(type)) return nil;				\
	return newLong(((type *)obj)[idx]);								\
    }													\
													\
    static subr(set_##name##_at)									\
    {													\
	arity3(args, "set-"#name"-at");									\
	oop obj= getHead(args);										\
	oop arg= getHead(getTail(args));								\
	oop val= getHead(getTail(getTail(args)));	if (!isLong(arg) || !isLong(val)) return nil;	\
	int idx= getLong(arg);										\
	if (is(Long, obj))										\
	    ((type *)getLong(obj))[idx]= getLong(val);							\
	else {												\
	    if ((unsigned)idx >= (unsigned)GC_size(obj) / sizeof(type)) return nil;			\
	    ((type *)obj)[idx]= getLong(val);								\
	}												\
	return val;											\
    }

accessor(byte,  unsigned char)
accessor(long,  long)

#undef accessor

#if !defined(WIN32)
# include <sys/mman.h>
#endif

static subr(native_call)
{
    oop  obj= car(args);
    struct { long l[34]; } argv;
    int  argc= 0;
    args= cdr(args);
    while (is(Pair, args) && argc < 32)
    {
	oop arg= getHead(args);
	args= getTail(args);
	switch (getType(arg))
	{
	    case Undefined:	argv.l[argc]= 0;						break;
	    case Long:		argv.l[argc]= getLong(arg);					break;
 	    case Double:	argc= (argc + 1) & -2;  argv.l[argc++]= ((long *)arg)[0];
				argv.l[argc]= ((long *)arg)[1];					break;
 	    case String:	argv.l[argc]= (long)wcs2mbs(get(arg, String,bits));		break;
	    case Subr:		argv.l[argc]= (long)get(arg, Subr,imp);				break;
	    default:		argv.l[argc]= (long)arg;					break;
	}
	++argc;
    }
    void  *addr= 0;
    size_t size= 0;
    switch (getType(obj))
    {
	case Data:	addr= obj;			size= GC_size(obj);	break;
	case Long:	addr= (void *)getLong(obj);				break;
	case Subr:	addr= get(obj, Subr,imp);				break;
	default:	fatal("call: cannot call object of type %i", getType(obj));
    }
    if (size) {
#     if !defined(WIN32)
	extern int getpagesize();
	void *start = (void *)((long)addr & -(long)getpagesize());	// round down to page boundary for Darwin
	size_t len  = (addr + size) - start;
	if (mprotect(start, len, PROT_READ | PROT_WRITE | PROT_EXEC)) perror("mprotect");
#     endif
    }
    return newLong(((int (*)())addr)(argv));
}

#if defined(WIN32)
# include "w32dlfcn.h"
#else
# define __USE_GNU
# include <dlfcn.h>
# undef __USE_GNU
#endif

static subr(subr)
{
    oop ptr= car(args);
    wchar_t *name= 0;
    switch (getType(ptr))
    {
	case String:	name= get(ptr, String,bits);  break;
	case Symbol:	name= get(ptr, Symbol,bits);  break;
	default:	fatal("subr: argument must be string or symbol");
    }
    char *sym= wcs2mbs(name);
    void *addr= dlsym(RTLD_DEFAULT, sym);
    if (!addr) fatal("could not find symbol: %s", sym);
    return newSubr(addr, name);
}

static subr(subr_name)
{
    oop arg= car(args);				if (!is(Subr, arg)) { fprintf(stderr, "subr-name: non-Subr argument: ");  fdumpln(stderr, arg);  fatal(0); }
    return newString(get(arg, Subr,name));
}

static subr(allocate)
{
  arity2(args, "allocate");
  oop type= getHead(args);			if (!isLong(type)) return nil;
  oop size= getHead(getTail(args));		if (!isLong(size)) return nil;
  return _newOops(getLong(type), sizeof(oop) * getLong(size));
}

static subr(oop_at)
{
  arity2(args, "oop-at");
  oop obj= getHead(args);
  oop arg= getHead(getTail(args));	if (!isLong(arg)) return nil;
  return oopAt(obj, getLong(arg));
}

static subr(set_oop_at)
{
  arity3(args, "set-oop-at");
  oop obj= getHead(args);
  oop arg= getHead(getTail(args));		if (!isLong(arg)) return nil;
  oop val= getHead(getTail(getTail(args)));
  return oopAtPut(obj, getLong(arg), val);
}

static subr(not)
{
  arity1(args, "not");
  oop obj= getHead(args);
  return (nil == obj) ? s_t : nil;
}

static subr(verbose)
{
  oop obj= car(args);
  if (nil == obj) return newLong(opt_v);
  if (!isLong(obj)) return nil;
  opt_v= getLong(obj);
  return obj;
}

static subr(optimised)
{
  oop obj= car(args);
  if (nil == obj) return newLong(opt_O);
  if (!isLong(obj)) return nil;
  opt_O= getLong(obj);
  return obj;
}

static subr(sin)
{
  oop obj= getHead(args);
  double arg= 0.0;
  if	  (isDouble(obj)) arg=         getDouble(obj);
  else if (isLong  (obj)) arg= (double)getLong  (obj);
  else {
    fprintf(stderr, "sin: non-numeric argument: ");
    fdumpln(stderr, obj);
    fatal(0);
  }
  return newDouble(sin(arg));
}

static subr(cos)
{
  oop obj= getHead(args);
  double arg= 0.0;
  if	  (isDouble(obj)) arg=         getDouble(obj);
  else if (isLong  (obj)) arg= (double)getLong  (obj);
  else {
    fprintf(stderr, "cos: non-numeric argument: ");
    fdumpln(stderr, obj);
    fatal(0);
  }
  return newDouble(cos(arg));
}

static subr(log)
{
  oop obj= getHead(args);
  double arg= 0.0;
  if	  (isDouble(obj)) arg=         getDouble(obj);
  else if (isLong  (obj)) arg= (double)getLong  (obj);
  else {
    fprintf(stderr, "log: non-numeric argument: ");
    fdumpln(stderr, obj);
    fatal(0);
  }
  return newDouble(log(arg));
}

static subr(address_of)
{
  oop arg= car(args);
  return newLong((long)arg);
}

#include <sys/time.h>
#if defined(WIN32)
    struct rusage {
      struct timeval ru_utime;
      struct timeval ru_stime;
    };

#   define RUSAGE_SELF 0

#   define timersub(a, b, result)					\
    do {								\
      (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			\
      (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			\
      if ((result)->tv_usec < 0) {					\
	--(result)->tv_sec;						\
	(result)->tv_usec += 1000000;					\
      }									\
    } while (0)

    static void getrusage(int who, struct rusage *ru)
    {
      clock_t cl= clock();
      long ms= cl * 1000 / CLOCKS_PER_SEC;
      ru->ru_utime.tv_sec=  (ms / 1000);
      ru->ru_utime.tv_usec= (ms % 1000) * 1000;
      ru->ru_stime.tv_sec=  0;
      ru->ru_stime.tv_usec= 0;
    }
#else
# include <sys/resource.h>
#endif

static struct timeval epoch;

static void init_times(void)
{
    gettimeofday(&epoch, 0);
}

static subr(times)
{
    struct timeval tv;
    struct rusage ru;
    gettimeofday(&tv, 0);
    getrusage(RUSAGE_SELF, &ru);
    timersub(&tv, &epoch, &tv);
    oop real= newLong(tv.tv_sec * 1000 + tv.tv_usec / 1000);			GC_PROTECT(real);
    oop user= newLong(ru.ru_utime.tv_sec * 1000 + ru.ru_utime.tv_usec / 1000);	GC_PROTECT(user);
    oop syst= newLong(ru.ru_stime.tv_sec * 1000 + ru.ru_stime.tv_usec / 1000);	GC_PROTECT(syst);
    syst= newPair(syst, nil);
    user= newPair(user, syst);							GC_UNPROTECT(syst);
    real= newPair(real, user);							GC_UNPROTECT(user);
										GC_UNPROTECT(real);
    return real;
}

#undef subr

static void replFile(FILE *stream, wchar_t *path)
{
  set(input, Variable,value, newLong((long)stream));
  beginSource(path);
  for (;;) {
    if (stream == stdin) {
      printf(".");
      fflush(stdout);
    }
    oop obj= read(stream);
    if (obj == DONE) break;
    GC_PROTECT(obj);
    if (opt_v) {
      dumpln(obj);
      fflush(stdout);
    }
    oop env= newEnv(get(globals, Variable,value), 1, 0);	GC_PROTECT(env);
    obj= expand(obj, env);
    obj= encode(obj, env);
    oop ctx= newBaseContext(nil, nil, env);			GC_PROTECT(ctx);
    obj= eval  (obj, ctx);					GC_UNPROTECT(ctx);  GC_UNPROTECT(env);
    if ((stream == stdin) || (opt_v > 0)) {
      printf(" => ");
      fflush(stdout);
      dumpln(obj);
      fflush(stdout);
    }
    GC_UNPROTECT(obj);
    if (opt_v) {
#if (!LIB_GC)
      GC_gcollect();
      printf("%ld collections, %ld objects, %ld bytes, %4.1f%% fragmentation\n",
	     (long)GC_collections, (long)GC_count_objects(), (long)GC_count_bytes(),
	     GC_count_fragments() * 100.0);
#endif
    }
  }
  int c= getwc(stream);
  if (WEOF != c)			fatal("unexpected character 0x%02x '%c'\n", c, c);
  endSource();
}

static void replPath(wchar_t *path)
{
  FILE *stream= fopen(wcs2mbs(path), "r");
  if (!stream) {
    int err= errno;
    fprintf(stderr, "\nerror: ");
    errno= err;
    perror(wcs2mbs(path));
    fatal(0);
  }
  fwide(stream, 1);
  fscanf(stream, "#!%*[^\012\015]");
  replFile(stream, path);
  fclose(stream);
}

static void sigint(int signo)
{
  fatal("\nInterrupt");
}

#if !defined(WIN32) && (!LIB_GC)

static int profilerCount= 0;

static void sigvtalrm(int signo)
{
    if (traceDepth < 1) return;
    ++profilerCount;
    oop func= arrayAt(traceStack, traceDepth - 1);
    switch (getType(func))
    {
	case Expr: {
	    oop profile= get(func, Expr,profile);
	    if ((long)profile & 1) {
		set(func, Expr,profile, (oop)((long)profile + 2));
	    }
	    else printf("? %p\n", func);
	    break;
	}
	case Subr: {
	    set(func, Subr,profile, 1 + get(func, Subr,profile));
	    break;
	}
    }
}

#include <sys/time.h>

static void profilingEnable(void)
{
    struct itimerval itv= { { 0, opt_p }, { 0, opt_p } };	/* VTALARM every opt_p mSecs */
    setitimer(ITIMER_VIRTUAL, &itv, 0);
}

static void profilingDisable(int stats)
{
    struct itimerval itv= { { 0, 0 }, { 0, 0 } };
    setitimer(ITIMER_VIRTUAL, &itv, 0);
    if (stats)
    {
	struct profile { int profile;  oop object, source; } profiles[64];
	int nprofiles= 0;
	fprintf(stderr, "%i profiles\n", profilerCount);
	GC_gcollect();
	oop obj;
	for (obj= GC_first_object();  obj;  obj= GC_next_object(obj)) {
	    int profile= 0;
	    oop source= nil;
	    switch (getType(obj))
	    {
		case Expr: {
		    oop oprof= get(obj, Expr,profile);
		    if (isLong(oprof)) {
			profile= getLong(get(obj, Expr,profile));
			source=  cddr(get(obj, Expr,defn));
		    }
		    break;
		}
		case Subr: {
		    profile= get(obj, Subr,profile);
		    break;
		}
	    }
	    if (profile) {
		int index= 0;
		while (index < nprofiles && profile <= profiles[index].profile) ++index;
		if (nprofiles < 64) ++nprofiles;
		int jndex;
		for (jndex= nprofiles - 1;  jndex > index;  --jndex) profiles[jndex] = profiles[jndex - 1];
		profiles[index]= (struct profile){ profile, obj, source };
	    }
	}
	int i;
	for (i= 0;  i < nprofiles;  ++i) {
	    fprintf(stderr, "%i\t", profiles[i].profile);
	    int l= fprintSource(stderr, profiles[i].source);
	    if (l < 20) fprintf(stderr, "%*s", 20 - l, "");
	    fprintf(stderr, " ");
	    fdumpln(stderr, profiles[i].object);
	}
    }
}

#endif

int main(int argc, char **argv)
{
  init_times();

  if ((fwide(stdin, 1) <= 0) || (fwide(stdout, -1) >= 0) || (fwide(stderr, -1) >= 0)) {
    fprintf(stderr, "Cannot set stream widths.\n");
    return 1;
  }

  if (!setlocale(LC_CTYPE, "")) {
    fprintf(stderr, "Cannot set the locale.  Verify your LANG, LC_CTYPE, LC_ALL.\n");
    return 1;
  }

  GC_INIT();

  GC_add_root(&symbols);
  GC_add_root(&globals);
  GC_add_root(&expanders);
  GC_add_root(&encoders);
  GC_add_root(&evaluators);
  GC_add_root(&applicators);
  GC_add_root(&backtrace);

  symbols= newArray(0);

  s_set			= intern(L"set");
  s_define		= intern(L"define");
  s_let			= intern(L"let");
  s_lambda		= intern(L"lambda");
  s_quote		= intern(L"quote");
  s_quasiquote		= intern(L"quasiquote");
  s_unquote		= intern(L"unquote");
  s_unquote_splicing	= intern(L"unquote-splicing");
  s_t			= intern(L"t");
  s_dot			= intern(L".");
  s_bracket		= intern(L"bracket");
  s_brace		= intern(L"brace");
//s_in			= intern(L"in");

  oop tmp= nil;		GC_PROTECT(tmp);

  globals= newEnv(nil, 0, 0);
  globals= define(globals, intern(L"*globals*"), globals);

  expanders=	define(get(globals, Variable,value), intern(L"*expanders*"),   nil);
  encoders=	define(get(globals, Variable,value), intern(L"*encoders*"),    nil);
  evaluators=	define(get(globals, Variable,value), intern(L"*evaluators*"),  nil);
  applicators=	define(get(globals, Variable,value), intern(L"*applicators*"), nil);

  traceStack=	newArray(32);					GC_add_root(&traceStack);

  backtrace=	define(get(globals, Variable,value), intern(L"*backtrace*"), nil);
  input=	define(get(globals, Variable,value), intern(L"*input*"), nil);
  output=	define(get(globals, Variable,value), intern(L"*output*"), nil);

  currentPath= nil;			GC_add_root(&currentPath);
  currentLine= nil;			GC_add_root(&currentLine);
  currentSource= newPair(nil, nil);	GC_add_root(&currentSource);

#define _do(NAME, OP)	tmp= newSubr(subr_##NAME, WIDEN(#OP));  define(get(globals, Variable,value), intern(WIDEN(#OP)), tmp);
  _do_unary();  _do_ibinary();  _do_binary();  _do(sub, -);  _do(mod, %);  _do_relation();  _do(eq, =);  _do(ne, !=);
#undef _do

  {
    struct { char *name;  imp_t imp; } *ptr, subrs[]= {
      { ".if",		   subr_if },
      { ".and",		   subr_and },
      { ".or",		   subr_or },
      { ".set",		   subr_set },
      { ".let",		   subr_let },
      { ".while",	   subr_while },
      { ".quote",	   subr_quote },
      { ".lambda",	   subr_lambda },
      { ".define",	   subr_define },
      { " defined?",	   subr_definedP },
      { " exit",	   subr_exit },
      { " abort",	   subr_abort },
//    { " current-environment",	   subr_current_environment },
      { " open",	   subr_open },
      { " close",	   subr_close },
      { " getb",	   subr_getb },
      { " getc",	   subr_getc },
      { " putb",	   subr_putb },
      { " putc",	   subr_putc },
      { " read",	   subr_read },
      { " expand",	   subr_expand },
      { " encode",	   subr_encode },
      { " eval",	   subr_eval },
      { " apply",	   subr_apply },
      { " type-of",	   subr_type_of },
      { " warn",	   subr_warn },
      { " print",	   subr_print },
      { " dump",	   subr_dump },
      { " format",	   subr_format },
      { " form",	   subr_form },
      { " fixed?",	   subr_fixedP },
      { " cons",	   subr_cons },
      { " pair?",	   subr_pairP },
      { " car",		   subr_car },
      { " set-car",	   subr_set_car },
      { " cdr",		   subr_cdr },
      { " set-cdr",	   subr_set_cdr },
      { " form?",	   subr_formP },
      { " symbol?",	   subr_symbolP },
      { " string?",	   subr_stringP },
      { " string", 	   subr_string },
      { " string-length",  subr_string_length },
      { " string-at",	   subr_string_at },
      { " set-string-at",  subr_set_string_at },
      { " string-copy",    subr_string_copy },
      { " string-compare", subr_string_compare },
      { " symbol->string", subr_symbol_string },
      { " string->symbol", subr_string_symbol },
      { " symbol-compare", subr_symbol_compare },
      { " long->double",   subr_long_double },
      { " long->string",   subr_long_string },
      { " string->long",   subr_string_long },
      { " double->long",   subr_double_long },
      { " double->string", subr_double_string },
      { " string->double", subr_string_double },
      { " array",	   subr_array },
      { " array?",	   subr_arrayP },
      { " array-length",   subr_array_length },
      { " array-at",	   subr_array_at },
      { " set-array-at",   subr_set_array_at },
      { " array-compare",  subr_array_compare },
      { " data",	   subr_data },
      { " data-length",	   subr_data_length },
      { " byte-at",	   subr_byte_at },
      { " set-byte-at",    subr_set_byte_at },
      { " long-at",        subr_long_at },
      { " set-long-at",    subr_set_long_at },
      { " native-call",	   subr_native_call },
      { " subr",	   subr_subr },
      { " subr-name",	   subr_subr_name },
      { " allocate",	   subr_allocate },
      { " oop-at",	   subr_oop_at },
      { " set-oop-at",	   subr_set_oop_at },
      { " not",		   subr_not },
      { " verbose",	   subr_verbose },
      { " optimised",	   subr_optimised },
      { " sin",		   subr_sin },
      { " cos",		   subr_cos },
      { " log",		   subr_log },
      { " address-of",	   subr_address_of },
      { " times",	   subr_times },
      { 0,		   0 }
    };
    for (ptr= subrs;  ptr->name;  ++ptr) {
      wchar_t *name= wcsdup(mbs2wcs(ptr->name + 1));
      tmp= newSubr(ptr->imp, name);
      if ('.' == ptr->name[0]) tmp= newFixed(tmp);
      define(get(globals, Variable,value), intern(name), tmp);
    }
  }

  tmp= nil;
  while (--argc) {
    tmp= newPair(nil, tmp);
    setHead(tmp, newString(mbs2wcs(argv[argc])));
  }
  arguments= define(get(globals, Variable,value), intern(L"*arguments*"), tmp);

  tmp= nil;		GC_UNPROTECT(tmp);

  f_set=    lookup(get(globals, Variable,value), s_set   );		GC_add_root(&f_set);
  f_quote=  lookup(get(globals, Variable,value), s_quote );		GC_add_root(&f_quote);
  f_lambda= lookup(get(globals, Variable,value), s_lambda);		GC_add_root(&f_lambda);
  f_let=    lookup(get(globals, Variable,value), s_let   );		GC_add_root(&f_let);
  f_define= lookup(get(globals, Variable,value), s_define);		GC_add_root(&f_let);

  int repled= 0;

  signal(SIGINT, sigint);

#if !defined(WIN32) && (!LIB_GC)
  {
      struct sigaction sa;
      sa.sa_handler= sigvtalrm;
      sigemptyset(&sa.sa_mask);
      sa.sa_flags= 0;
      if (sigaction(SIGVTALRM, &sa, 0)) perror("vtalrm");
  }
#endif

  while (is(Pair, get(arguments, Variable,value))) {
    oop argl= get(arguments, Variable,value);		GC_PROTECT(argl);
    oop args= getHead(argl);
    oop argt= getTail(argl);
    wchar_t *arg= get(args, String,bits);
    if 	    (!wcscmp (arg, L"-v"))	{ ++opt_v; }
    else if (!wcscmp (arg, L"-b"))	{ ++opt_b; }
    else if (!wcscmp (arg, L"-g"))	{ ++opt_g;  opt_p= 0; }
    else if (!wcscmp (arg, L"-O"))	{ ++opt_O; }
#  if !defined(WIN32) && (!LIB_GC)
    else if (!wcsncmp(arg, L"-p", 2)) {
	opt_g= 0;
	opt_p= wcstoul(arg + 2, 0, 0);
	if (!opt_p) opt_p= 1000;
	printf("profiling every %i uSec(s)\n", opt_p);
    }
#  endif
    else
    {
	if (!opt_b)
	{
	    replPath(L"src/boot.l");
	    opt_b= 1;
	}
	else
	{
#          if !defined(WIN32) && (!LIB_GC)
	    if (opt_p) profilingEnable();
#	   endif
	    set(arguments, Variable,value, argt);
	    replPath(arg);
	    repled= 1;
#	   if !defined(WIN32) && (!LIB_GC)
	    if (opt_p) profilingDisable(0);
#	   endif
	}
	argt= get(arguments, Variable,value);
    }
    set(arguments, Variable,value, argt);		GC_UNPROTECT(argl);
  }

  if (opt_v) {
#if (!LIB_GC)
    GC_gcollect();
    printf("%ld collections, %ld objects, %ld bytes, %4.1f%% fragmentation\n",
	   (long)GC_collections, (long)GC_count_objects(), (long)GC_count_bytes(),
	   GC_count_fragments() * 100.0);
#endif
  }

  set(output, Variable,value, newLong((long)stdout));

  if (!repled) {
    if (!opt_b) replPath(L"src/boot.l");
    replFile(stdin, L"<stdin>");
    printf("\nmorituri te salutant\n");
  }

#if !defined(WIN32) && (!LIB_GC)
  if (opt_p) profilingDisable(1);
#endif

  return 0;
}
#+end_src

*** bootstrap/gc.h

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/gc.h
#ifndef _GC_H_
#define _GC_H_

struct GC_StackRoot
{
  void **root;
  struct GC_StackRoot *next;
#if !defined(NDEBUG)
  int	      live;
  const char *name;
  const char *file;
        long  line;
#endif
};

#if defined(NDEBUG)
# define GC_PROTECT(V)		struct GC_StackRoot _sr_##V;  _sr_##V.root= (void *)&V;  GC_push_root(&_sr_##V)
# define GC_UNPROTECT(V)								 GC_pop_root(&_sr_##V)
#else
# define GC_PROTECT(V)		struct GC_StackRoot _sr_##V;  _sr_##V.root= (void *)&V;	 GC_push_root(&_sr_##V, #V, __FILE__, __LINE__)
# define GC_UNPROTECT(V)								 GC_pop_root(&_sr_##V,  #V, __FILE__, __LINE__)
#endif


#define GC_INIT()
#define GC_init()

#if !defined(GC_API)
# define GC_API
#endif

GC_API	void   *GC_malloc(size_t nbytes);
GC_API	void   *GC_malloc_atomic(size_t nbytes);
GC_API	void   *GC_realloc(void *ptr, size_t lbs);
GC_API	void   	GC_free(void *ptr);
GC_API	size_t 	GC_size(void *ptr);
GC_API	void   	GC_add_root(void *root);
GC_API	void   	GC_delete_root(void *root);
GC_API	void   	GC_mark(void *ptr);
GC_API	void   	GC_mark_leaf(void *ptr);
GC_API	void   	GC_sweep(void);
GC_API	void   	GC_gcollect(void);
GC_API	size_t 	GC_count_objects(void);
GC_API	size_t 	GC_count_bytes(void);
GC_API	double 	GC_count_fragments(void);

GC_API	void   *GC_first_object(void);
GC_API	void   *GC_next_object(void *prev);

GC_API	int 	GC_atomic(void *ptr);

#ifndef NDEBUG
GC_API	void	   *GC_check(void *ptr);
GC_API	void	   *GC_stamp(void *ptr, const char *file, long line, const char *func);
GC_API	const char *GC_file(void *ptr);
GC_API	long	    GC_line(void *ptr);
GC_API	const char *GC_function(void *ptr);
#else
# define GC_check(PTR)				(PTR)
# define GC_stamp(PTR, FILE, LINE, FUNC)	(PTR)
# define GC_file(PTR)				"?"
# define GC_line(PTR)				0
# define GC_function(PTR)			"?"
#endif

typedef void (*GC_finaliser_t)(void *ptr, void *data);

GC_API	void GC_register_finaliser(void *ptr, GC_finaliser_t finaliser, void *data);

extern struct GC_StackRoot *GC_stack_roots;

#if defined(NDEBUG)

  GC_API inline void GC_push_root(struct GC_StackRoot *sr)
  {
    sr->next= GC_stack_roots;
    GC_stack_roots= sr;
  }

  GC_API inline void GC_pop_root(struct GC_StackRoot *sr)
  {
#  if 0
    GC_stack_roots= sr->next;
#  else /* paranoid version for broken code warns of mismatched pops with a SEGV */
    struct GC_StackRoot *nr= sr->next;
    while (nr != GC_stack_roots) GC_stack_roots= GC_stack_roots->next;
#  endif
  }

#else

  GC_API inline void GC_push_root(struct GC_StackRoot *sr, const char *name, const char *file, int line)
  {
    sr->next= GC_stack_roots;
    sr->name= name;
    sr->file= file;
    sr->line= line;
    sr->live= 1;
    GC_stack_roots= sr;
  }

  static int GC_roots_include(struct GC_StackRoot *roots, struct GC_StackRoot *root)
  {
    while (roots) {
      if (roots == root) return 1;
      roots= roots->next;
    }
    return 0;
  }

  GC_API inline void GC_pop_root(struct GC_StackRoot *sr, const char *name, const char *file, int line)
  {
    struct GC_StackRoot *nr= sr->next;
    struct GC_StackRoot *gr= GC_stack_roots;
    if (!sr->live)			{ fprintf(stderr, "*** %s %d %s: STALE POP IN GC_pop_root\n", file, line, name);  goto die; }
    sr->live= 0;
    if (GC_roots_include(nr, sr))	{ fprintf(stderr, "*** %s %d %s: CYCLE IN GC_pop_root\n", file, line, name);  goto die; }
    int n= 0;
    while (nr != gr) {
      if (n++ > 10) { fprintf(stderr, "*** %s %d %s: LOOP IN GC_pop_root\n", file, line, name);  goto die; }
      gr= gr->next;
    }
    GC_stack_roots= gr;
    return;
  die:
    fprintf(stderr, "* gc stack roots = %p %s %ld %s\n", gr, gr->file, gr->line, gr->name);
    fprintf(stderr, "* popped root    = %p %s %ld %s\n", sr, sr->file, sr->line, sr->name);
    while (nr) {
      fprintf(stderr, "* next root      = %p %s %ld %s\n", nr, nr ? nr->file : 0, nr ? nr->line : 0, nr ? nr->name : 0);
      nr= nr->next;
    }
    abort();
  }

#endif

typedef void (*GC_pre_mark_function_t)(void);
extern GC_pre_mark_function_t GC_pre_mark_function;

typedef void (*GC_mark_function_t)(void *ptr);
extern GC_mark_function_t GC_mark_function;

typedef void (*GC_free_function_t)(void *ptr);
extern GC_free_function_t GC_free_function;

#endif /* _GC_H_ */
#+end_src

*** bootstrap/gc.c

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/gc.c
// gc.c -- trivial single-threaded stop-world non-moving mark-sweep collector
//
// Copyright (c) 2008 Ian Piumarta
// All Rights Reserved
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the 'Software'),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, provided that the above copyright notice(s) and this
// permission notice appear in all copies of the Software.  Inclusion of the
// the above copyright notice(s) and this permission notice in supporting
// documentation would be appreciated but is not required.
//
// THE SOFTWARE IS PROVIDED 'AS IS'.  USE ENTIRELY AT YOUR OWN RISK.
//
// Last edited: 2011-10-14 17:04:43 by piumarta on debian.piumarta.com
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <assert.h>

#include "gc.h"

#define GC_ALIGN	sizeof(long)
#define GC_MEMORY	0x7fffffff
#define GC_QUANTUM	50*1024
#if defined(DEBUGGC)
# define ALLOCS_PER_GC	1
#else
# define ALLOCS_PER_GC	32768
#endif

#define VERBOSE		0

#define BITS_PER_WORD	(sizeof(long) * 8)

typedef struct _gcheader
{
  unsigned long		size  : BITS_PER_WORD - 8	__attribute__((__packed__));
  union {
    unsigned int	flags : 3;
    struct {
      unsigned int	used  : 1;
      unsigned int	atom  : 1;
      unsigned int	mark  : 1;
    }							__attribute__((__packed__));
  }							__attribute__((__packed__));
  struct _gcheader *next;
  struct _gcfinaliser	*finalisers;
#ifndef NDEBUG
  const char	*file;
  long		 line;
  const char	*func;
#endif
#if defined(GC_APP_HEADER)
  GC_APP_HEADER
#endif
} gcheader;

static inline void *hdr2ptr(gcheader *hdr)	{ return (void *)(hdr + 1); }
static inline gcheader *ptr2hdr(void *ptr)	{ return (gcheader *)ptr - 1; }

#ifndef NDEBUG

GC_API void *GC_stamp(void *ptr, const char *file, long line, const char *func)
{
  gcheader *hdr= ptr2hdr(ptr);
  hdr->file= file;
  hdr->line= line;
  hdr->func= func;
  return ptr;
}

GC_API const char *GC_file(void *ptr)		{ return ptr2hdr(ptr)->file; }
GC_API long	   GC_line(void *ptr)		{ return ptr2hdr(ptr)->line; }
GC_API const char *GC_function(void *ptr)	{ return ptr2hdr(ptr)->func; }

#endif

typedef struct _gcfinaliser
{
  void			*ptr;
  GC_finaliser_t	 finaliser;
  void			*data;
  struct _gcfinaliser	*next;
} gcfinaliser;

static gcheader  gcbase= { 0, { -1 }, &gcbase };
static gcheader *gcnext= &gcbase;

static size_t	gcQuantum= GC_QUANTUM;
static int	gcCount=   ALLOCS_PER_GC;
static int	gcAllocs=  ALLOCS_PER_GC;
static size_t	gcMemory=  GC_MEMORY;

static gcfinaliser *finalisable= 0;

//static void bkpt() {}

GC_API void *GC_malloc(size_t lbs)
{
  gcheader *hdr, *org;
  size_t split;
  if ((!--gcAllocs) || (gcMemory < lbs)) {
    //fprintf(stderr, "%i %lu %ld\t", gcAllocs, gcMemory, lbs);
#  if VERBOSE >= 1
    if (gcAllocs > 0) fprintf(stderr, "GC: heap full after %i allocations\n", gcCount - gcAllocs);
#  endif
    gcAllocs= gcCount;
    GC_gcollect();
    //fprintf(stderr, "GC %i %lu %ld\n", gcAllocs, gcMemory, lbs);
    if (gcMemory < lbs) goto full;
  }
  org= hdr= gcnext;
  lbs= (lbs + GC_ALIGN-1) & ~(GC_ALIGN-1);
#if VERBOSE > 1
  fprintf(stderr, "malloc %i\n", (int)lbs);
#endif
 again:
#if VERBOSE > 4
  {
    gcheader *h= gcnext;
    do { 
      fprintf(stderr, "  %2d %p -> %p = %i\n", h->flags, h, h->next, (int)h->size);
      h= h->next;
    } while (h != gcnext);
  }
#endif
  split= lbs + sizeof(gcheader) + GC_ALIGN;
  do {
#  if VERBOSE > 3
    fprintf(stderr, "? %2d %p -> %p = %i\n", hdr->flags, hdr, hdr->next, (int)hdr->size);
#  endif
    if (!hdr->used) {
      while ((!hdr->next->used) && (hdr2ptr(hdr) + hdr->size == hdr->next)) {
	hdr->size += sizeof(gcheader) + hdr->next->size;
	hdr->next= hdr->next->next;
      }
      if ((hdr->size >= split) || (hdr->size == lbs))
	{
	  void *mem;
	  if (hdr->size >= split)
	    {
	      gcheader *ins= (gcheader *)(hdr2ptr(hdr) + lbs);
	      ins->flags= 0;
	      ins->next= hdr->next;
	      ins->size= hdr->size - lbs - sizeof(gcheader);
	      hdr->next= ins;
	      hdr->size= lbs;
	    }
	  hdr->used= 1;
	  hdr->finalisers= 0;
	  gcnext= hdr->next;
	  mem= hdr2ptr(hdr);
#      if VERBOSE > 2
	  //if ((long)hdr == 0x800248) abort();
	  fprintf(stderr, "MALLOC %p -> %p + %i\n", mem, hdr, (int)GC_size(mem));
#      endif
	  memset(mem, 0, hdr->size);
	  gcMemory -= hdr->size;
	  //if (mem == (void *)0x82dd534) { fprintf(stderr, "ALLOCATING %p\n", mem);  bkpt(); }
	  return mem;
	}
    }
    hdr= hdr->next;
  } while (hdr != org);
  {
    size_t incr= gcQuantum;
    size_t req= sizeof(gcheader) + lbs;
    while (incr <= req) incr *= 2;
    //fprintf(stderr, "extending by %ld => %ld @ %d\n", req, incr, (int)(gcCount - gcAllocs));
    hdr= (gcheader *)malloc(incr);
    //fprintf(stderr, "buffer at %x\n", (int)hdr);
    if (hdr != (gcheader *)-1)
      {
	hdr->flags= 0;
	hdr->next= gcbase.next;
	gcbase.next= hdr;
	hdr->size= incr - sizeof(gcheader);
#if VERBOSE
	fprintf(stderr, "extend by %i at %p\n", (int)hdr->size, hdr);
#endif
	goto again;
      }
    fprintf(stderr, "GC: sbrk failed\n");
  }
 full:
  fprintf(stderr, "GC: out of memory\n");
  abort();
  return 0;
}

GC_API void *GC_malloc_atomic(size_t lbs)
{
  void *mem= GC_malloc(lbs);
  ptr2hdr(mem)->atom= 1;
  return mem;
}

GC_API void *GC_realloc(void *ptr, size_t lbs)
{
  gcheader *hdr= ptr2hdr(ptr);
  void *mem;
  if (lbs <= hdr->size) return ptr;
  mem= GC_malloc(lbs);
  memcpy(mem, ptr, hdr->size);
  ptr2hdr(mem)->atom= hdr->atom;
  GC_free(ptr);
  return mem;
}

static gcheader *GC_freeHeader(gcheader *hdr)
{
#if VERBOSE > 2
  fprintf(stderr, "FREE %p -> %p %s:%ld %s\n", hdr2ptr(hdr), hdr, hdr->file, hdr->line, hdr->func);
  if (hdr->line == 0) {
    fflush(stdout);
    abort();
  }
#endif
  hdr->flags= 0;
  gcMemory += hdr->size;
  return hdr;
}

GC_API void GC_free(void *ptr)
{
  gcnext= GC_freeHeader(ptr2hdr(ptr));
}

GC_API size_t GC_size(void *ptr)
{
  return ptr2hdr(ptr)->size;
}

GC_API void GC_default_pre_mark_function(void) {}

GC_pre_mark_function_t GC_pre_mark_function= GC_default_pre_mark_function;

GC_API void GC_default_mark_function(void *ptr)
{
  gcheader *hdr= ptr2hdr(ptr);
  void	  **pos= ptr;
  void	  **lim= hdr2ptr(hdr) + hdr->size - sizeof(void *);
  while (pos <= lim)
    {
      void *field= *pos;
      if (field && !((long)field & 1))
	GC_mark(field);
      ++pos;
    }
}

GC_mark_function_t GC_mark_function= GC_default_mark_function;

GC_API void GC_mark(void *ptr)
{
  if ((long)ptr & 1) return;
  gcheader *hdr= ptr2hdr(ptr);
#if VERBOSE > 3
  fprintf(stderr, "mark? %p -> %p used %d atom %d mark %d\n", ptr, hdr, hdr->used, hdr->atom, hdr->mark);
#endif
  if (!hdr->mark) {
    hdr->mark= 1;
    if (!hdr->atom)
      GC_mark_function(ptr);
  }
}

GC_API void GC_mark_leaf(void *ptr)
{
  ptr2hdr(ptr)->mark= 1;
}

GC_free_function_t GC_free_function= 0;

GC_API void GC_sweep(void)
{
  gcheader *hdr= gcbase.next;
  do {
#if VERBOSE > 3
    fprintf(stderr, "sweep? %p %d\n", hdr, hdr->flags);
#endif
    if (hdr->flags)
      {
	if (hdr->mark)
	  hdr->mark= 0;
	else {
	  if (hdr->finalisers) {
	    while (hdr->finalisers) {
	      gcfinaliser *gcf= hdr->finalisers;
	      hdr->finalisers= gcf->next;
	      gcf->next= finalisable;
	      finalisable= gcf;
	    }
	  }
	  else {
	    if (GC_free_function) GC_free_function(hdr2ptr(hdr));
	    hdr= GC_freeHeader(hdr);
	  }
	}
      }
    hdr= hdr->next;
  } while (hdr != &gcbase);
  gcnext= gcbase.next;
  while (finalisable)
    {
      gcfinaliser *gcf= finalisable;
      gcf->finaliser(gcf->ptr, gcf->data);
      finalisable= gcf->next;
      free(gcf);
    }
}

static void ***roots= 0;
static size_t numRoots= 0;
static size_t maxRoots= 0;

struct GC_StackRoot *GC_stack_roots= 0;

GC_API void GC_add_root(void *root)
{
  if (numRoots == maxRoots)
    roots= maxRoots
      ? realloc(roots, sizeof(roots[0]) * (maxRoots *= 2))
      : malloc (       sizeof(roots[0]) * (maxRoots= 128));
  roots[numRoots++]= (void **)root;
  assert(root);
}

GC_API void GC_delete_root(void *root)
{
  int i;
  for (i= 0;  i < numRoots;  ++i)
    if (roots[i] == (void **)root)
      break;
  if (i < numRoots)
    {
      memmove(roots + i, roots + i + 1, sizeof(roots[0]) * (numRoots - i));
      --numRoots;
    }
}

GC_API long GC_collections= 0;

GC_API void GC_gcollect(void)
{
  int i;
  struct GC_StackRoot *sr;
  ++GC_collections;
#if !defined(NDEBUG)
  {
#  undef static
    static char *cursors= "-/|\\";
    static int cursor= 0;
    if (GC_collections % 1000 == 0) {
      if (0 == cursors[cursor]) cursor= 0;
      fprintf(stderr, "%c\010", cursors[cursor]);
      ++cursor;
    }
#  if (NONSTATIC)
#    define static
#  endif
  }
#endif
  GC_pre_mark_function();
#if VERBOSE >= 1
  fprintf(stderr, "*** GC: mark roots\n");
#endif
  for (i= 0;  i < numRoots;  ++i)
    if (*roots[i]) {
#    if VERBOSE >= 2
      fprintf(stderr, "*** GC: root %i *%p -> %p\n", i, roots[i], *roots[i]);
#    endif
      GC_mark(*roots[i]);
    }
#if VERBOSE > 0
  fprintf(stderr, "*** GC: mark stack\n");
#endif
  for (sr= GC_stack_roots;  sr;  sr= sr->next)	{
#if VERBOSE > 2 && defined(DEBUGGC)
    fprintf(stderr, "*** GC: stack root %p %s %s:%ld\n", *sr->root, sr->name, sr->file, sr->line);
#endif
    if (*(sr->root)) GC_mark(*(sr->root));
  }
#if VERBOSE > 0
  fprintf(stderr, "*** GC: sweep\n");
#endif
  GC_sweep();
#if VERBOSE > 0
  fprintf(stderr, "*** GC: done\n");
#endif
}

GC_API size_t GC_count_objects(void)
{
  gcheader *hdr= gcbase.next;
  size_t count= 0;
  do {
    if (hdr->used)
      ++count;
    hdr= hdr->next;
  } while (hdr != &gcbase);
  return count;
}

GC_API size_t GC_count_bytes(void)
{
  gcheader *hdr= gcbase.next;
  size_t count= 0;
  do {
    if (hdr->used)
      count += hdr->size;
    hdr= hdr->next;
  } while (hdr != &gcbase);
  return count;
}

GC_API double GC_count_fragments(void)
{
  gcheader *hdr= gcbase.next;
  size_t used= 0;
  size_t free= 0;
  do {
    if (hdr->used) {
      ++used;
      //printf("%p\t%7d\n",   hdr, (int)hdr->size);
    }
    else {
      while ((!hdr->next->used) && (hdr2ptr(hdr) + hdr->size == hdr->next)) {
	hdr->size += sizeof(gcheader) + hdr->next->size;
	hdr->next= hdr->next->next;
      }
      ++free;
      //printf("%p\t\t%7d\n", hdr, (int)hdr->size); 
    }
    hdr= hdr->next;
  } while (hdr != &gcbase);
  return (double)free / (double)used;
}

GC_API void *GC_first_object(void)
{
    gcheader *hdr= gcbase.next;
    while (!hdr->used && hdr != &gcbase) hdr= hdr->next;
    if (hdr == &gcbase) return 0;
    return hdr2ptr(hdr);
}

GC_API void *GC_next_object(void *ptr)
{
    if (!ptr) return 0;
    gcheader *hdr= ptr2hdr(ptr)->next;
    while (!hdr->used && hdr != &gcbase) hdr= hdr->next;
    if (hdr == &gcbase) return 0;
    return hdr2ptr(hdr);
}

GC_API int GC_atomic(void *ptr)
{
  return ptr2hdr(ptr)->atom;
}

#ifndef NDEBUG

GC_API void *GC_check(void *ptr)
{
  gcheader *hdr= ptr2hdr(ptr);
  if (!hdr->used) {
    hdr->used= 1;
    printf("accessible dead object %p %s:%ld %s\n", ptr, hdr->file, hdr->line, hdr->func);
  }
  return ptr;
}

#endif

GC_API void GC_register_finaliser(void *ptr, GC_finaliser_t finaliser, void *data)
{
  gcheader    *gch = ptr2hdr(ptr);
  gcfinaliser *gcf = (struct _gcfinaliser *)malloc(sizeof(struct _gcfinaliser));
  gcf->ptr         = ptr;
  gcf->finaliser   = finaliser;
  gcf->data        = data;
  gcf->next        = gch->finalisers;
  gch->finalisers  = gcf;
}


#if 0

#undef VERBOSE
//#define VERBOSE 1

#include <stdlib.h>

long objs= 0, bytes= 0;

#define RAND(N)	({ long n= (1 + (int)((float)N * (rand() / (RAND_MAX + 1.0))));  bytes += n;  n; })

struct cell { int tag;  struct cell *next; };

void *mklist(int n)
{
  struct cell *cell;
  if (!n) return 0;
  cell= GC_malloc(8);  ++objs;  bytes += 8;
  GC_PROTECT(cell);
  cell->tag= n << 1 | 1;
  cell->next= mklist(n - 1);
  GC_UNPROTECT(cell);
  return cell;
}

void delist(struct cell *cell)
{
  if (cell && cell->next && cell->next->next) {
    cell->next= cell->next->next;
    delist(cell->next->next);
  }
}

int main()
{
  int i, j;
  void *a, *b, *c, *d, *e;
  for (i= 0;  i < 10000;  ++i) {
    a= 0;  GC_PROTECT(a);
    b= 0;  GC_PROTECT(b);
    c= 0;  GC_PROTECT(c);
    d= 0;  GC_PROTECT(d);
    e= 0;  GC_PROTECT(e);
#if !VERBOSE
# define printf(...)
#endif
    //#define GC_malloc malloc
    //#define GC_free free
    a= GC_malloc(RAND(1));	    printf("%p\n", a);	++objs;
    b= GC_malloc(RAND(10));	    printf("%p\n", b);	++objs;
    c= GC_malloc(RAND(100));	    printf("%p\n", c);	++objs;
    d= GC_malloc(RAND(1000));	    printf("%p\n", d);	++objs;
    e= GC_malloc(RAND(10000));	    printf("%p\n", e);	++objs;
    GC_free(a);  a= 0;
    GC_free(b);  b= 0;
    //    GC_free(c);
    GC_free(d);  d= 0;
    GC_free(e);  e= 0;
    a= GC_malloc(RAND(100));	    printf("%p\n", a);	++objs;
    b= GC_malloc(RAND(200));	    printf("%p\n", b);	++objs;
    c= GC_malloc(RAND(300));	    printf("%p\n", c);	++objs;
    d= GC_malloc(RAND(400));	    printf("%p\n", d);	++objs;
    e= GC_malloc(RAND(500));	    printf("%p\n", e);	++objs;
    GC_free(e);  e= 0;
    GC_free(d);  d= 0;
    //    GC_free(c);
    GC_free(b);  b= 0;
    GC_free(a);  a= 0;
    a= GC_malloc(RAND(4));	    printf("%p\n", a);	++objs;
    b= GC_malloc(RAND(16));	    printf("%p\n", b);	++objs;
    c= GC_malloc(RAND(64));	    printf("%p\n", c);	++objs;
    d= GC_malloc(RAND(256));	    printf("%p\n", d);	++objs;
    e= GC_malloc(RAND(1024));	    printf("%p\n", e);	++objs;
    GC_free(e);  e= 0;
    GC_free(b);  b= 0;
    //    GC_free(c);
    GC_free(d);  d= 0;
    GC_free(a);  a= 0;
    a= GC_malloc(RAND(713));	    printf("%p\n", a);	++objs;
    b= GC_malloc(RAND(713));	    printf("%p\n", b);	++objs;
    c= GC_malloc(RAND(713));	    printf("%p\n", c);	++objs;
    d= GC_malloc(RAND(713));	    printf("%p\n", d);	++objs;
    e= GC_malloc(RAND(713));	    printf("%p\n", e);	++objs;
    GC_free(a);  a= 0;
    GC_free(c);  c= 0;
    //    GC_free(e);
    GC_free(d);  d= 0;
    GC_free(b);  b= 0;
#undef printf
    if (i % 1000 == 0) printf("alloc: %ld bytes in %ld objects; alive: %ld bytes in %ld objects\n", bytes, objs, GC_count_bytes(), GC_count_objects());
    GC_gcollect();
    if (i % 1000 == 0) printf("   gc: %ld bytes in %ld objects; alive: %ld bytes in %ld objects\n", bytes, objs, GC_count_bytes(), GC_count_objects());
    GC_UNPROTECT(a);
  }
  {
    a= 0;
    GC_PROTECT(a);
    for (i= 0;  i < 10;  ++i) {
      for (j= 0;  j < 100;  ++j) {
	a= mklist(2000);
	delist(a);
#if VERBOSE
	{
	  struct cell *c= a;
	  printf("----\n");
	  while (c) {
	    printf("%p %d %p\n", c, c->tag >> 1, c->next);
	    c= c->next;
	  }
	}
#endif
      }
    printf("alloc: %ld bytes in %ld objects; alive: %ld bytes in %ld objects\n", bytes, objs, GC_count_bytes(), GC_count_objects());
    GC_gcollect();
    printf("   gc: %ld bytes in %ld objects; alive: %ld bytes in %ld objects\n", bytes, objs, GC_count_bytes(), GC_count_objects());
    }
    GC_UNPROTECT(a);
  }
  printf("alive: %ld bytes in %ld objects\n", GC_count_bytes(), GC_count_objects());
  GC_gcollect();
  printf("   gc: %ld bytes in %ld objects\n", GC_count_bytes(), GC_count_objects());
  printf("   gc: %ld collections\n", GC_collections);
  return 0;
}

#endif
#+end_src

*** bootstrap/buffer.c

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/buffer.c
struct buffer
{
  wchar_t	*buffer;
  int		 size;
  int		 position;
};

#define BUFFER_INITIALISER { 0, 0, 0 }

static void buffer_reset(struct buffer *b)		{ b->position= 0; }

#if 0
static int  buffer_position(struct buffer *b)		{ return b->position; }
#endif

#if 0
static int  buffer_last(struct buffer *b)		{ return (b->position > 0) ? b->buffer[b->position - 1] : -1; }
#endif

#if 0
static int buffer_read(struct buffer *b)
{
  int c= b->buffer[b->position++];
  if (!c) b->position--;
  return c;
}
#endif

static void buffer_append(struct buffer *b, int c)
{
  if (b->position == b->size)
    b->buffer= b->buffer
	? realloc(b->buffer, sizeof(wchar_t) * (b->size *= 2))
	: malloc(sizeof(wchar_t) * (b->size= 32));
  b->buffer[b->position++]= c;
}

static void buffer_appendAll(struct buffer *b, const wchar_t *s)
{
  while (*s) buffer_append(b, *s++);
}

#if 0
static void buffer_seek(struct buffer *b, int off)
{
  if (off < 0)	{ if ((b->position += off) < 0) b->position= 0; }
  else		{ while (off--) buffer_append(b, 0); }
}
#endif

static wchar_t *buffer_contents(struct buffer *b)
{
  buffer_append(b, 0);
  b->position--;
  return (wchar_t *)b->buffer;
}
#+end_src

*** bootstrap/chartab.h

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/chartab.h
#define CHAR_PRINT	(1<<0)
#define CHAR_BLANK	(1<<1)
#define CHAR_ALPHA	(1<<2)
#define CHAR_DIGIT10	(1<<3)
#define CHAR_DIGIT16	(1<<4)
#define CHAR_LETTER	(1<<5)

static char chartab[]= {
  /*  00 nul */	0,
  /*  01 soh */	0,
  /*  02 stx */	0,
  /*  03 etx */	0,
  /*  04 eot */	0,
  /*  05 enq */	0,
  /*  06 ack */	0,
  /*  07 bel */	0,
  /*  08 bs  */	0,
  /*  09 ht  */	0,
  /*  0a nl  */	CHAR_PRINT | CHAR_BLANK,
  /*  0b vt  */	0,
  /*  0c np  */	CHAR_PRINT | CHAR_BLANK,
  /*  0d cr  */	CHAR_PRINT | CHAR_BLANK,
  /*  0e so  */	0,
  /*  0f si  */	0,
  /*  10 dle */	0,
  /*  11 dc1 */	0,
  /*  12 dc2 */	0,
  /*  13 dc3 */	0,
  /*  14 dc4 */	0,
  /*  15 nak */	0,
  /*  16 syn */	0,
  /*  17 etb */	0,
  /*  18 can */	0,
  /*  19 em  */	0,
  /*  1a sub */	0,
  /*  1b esc */	0,
  /*  1c fs  */	0,
  /*  1d gs  */	0,
  /*  1e rs  */	0,
  /*  1f us  */	0,
  /*  20 sp  */	CHAR_PRINT | CHAR_BLANK,
  /*  21  !  */	CHAR_PRINT | CHAR_LETTER,
  /*  22  "  */	CHAR_PRINT | CHAR_PRINT,
  /*  23  #  */	CHAR_PRINT | CHAR_LETTER,
  /*  24  $  */	CHAR_PRINT | CHAR_LETTER,
  /*  25  %  */	CHAR_PRINT | CHAR_LETTER,
  /*  26  &  */	CHAR_PRINT | CHAR_LETTER,
  /*  27  '  */	CHAR_PRINT,
  /*  28  (  */	CHAR_PRINT,
  /*  29  )  */	CHAR_PRINT,
  /*  2a  *  */	CHAR_PRINT | CHAR_LETTER,
  /*  2b  +  */	CHAR_PRINT | CHAR_LETTER,
  /*  2c  ,  */	CHAR_PRINT | CHAR_LETTER,
  /*  2d  -  */	CHAR_PRINT | CHAR_LETTER,
  /*  2e  .  */	CHAR_PRINT | CHAR_LETTER,
  /*  2f  /  */	CHAR_PRINT | CHAR_LETTER,
  /*  30  0  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  31  1  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  32  2  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  33  3  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  34  4  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  35  5  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  36  6  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  37  7  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  38  8  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  39  9  */	CHAR_PRINT | CHAR_DIGIT10 | CHAR_DIGIT16,
  /*  3a  :  */	CHAR_PRINT | CHAR_LETTER,
  /*  3b  ;  */	CHAR_PRINT,
  /*  3c  <  */	CHAR_PRINT | CHAR_LETTER,
  /*  3d  =  */	CHAR_PRINT | CHAR_LETTER,
  /*  3e  >  */	CHAR_PRINT | CHAR_LETTER,
  /*  3f  ?  */	CHAR_PRINT | CHAR_LETTER,
  /*  40  @  */	CHAR_PRINT | CHAR_LETTER,
  /*  41  A  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  42  B  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  43  C  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  44  D  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  45  E  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  46  F  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  47  G  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  48  H  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  49  I  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4a  J  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4b  K  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4c  L  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4d  M  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4e  N  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  4f  O  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  50  P  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  51  Q  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  52  R  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  53  S  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  54  T  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  55  U  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  56  V  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  57  W  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  58  X  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  59  Y  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  5a  Z  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  5b  [  */	CHAR_PRINT,
  /*  5c  \  */	CHAR_PRINT | CHAR_LETTER,
  /*  5d  ]  */	CHAR_PRINT,
  /*  5e  ^  */	CHAR_PRINT | CHAR_LETTER,
  /*  5f  _  */	CHAR_PRINT | CHAR_LETTER,
  /*  60  `  */	CHAR_PRINT,
  /*  61  a  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  62  b  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  63  c  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  64  d  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  65  e  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  66  f  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA | CHAR_DIGIT16,
  /*  67  g  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  68  h  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  69  i  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6a  j  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6b  k  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6c  l  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6d  m  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6e  n  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  6f  o  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  70  p  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  71  q  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  72  r  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  73  s  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  74  t  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  75  u  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  76  v  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  77  w  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  78  x  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  79  y  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  7a  z  */	CHAR_PRINT | CHAR_LETTER | CHAR_ALPHA,
  /*  7b  {  */	CHAR_PRINT,
  /*  7c  | */	CHAR_PRINT | CHAR_LETTER,
  /*  7d  }  */	CHAR_PRINT,
  /*  7e  ~  */	CHAR_PRINT | CHAR_LETTER,
  /*  7f del */	0,
};
#+end_src

*** bootstrap/wcs.c

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/wcs.c
#define _WIDEN(x)  L ## x
#define WIDEN(x)   _WIDEN(x)

#include <stdlib.h>

static wchar_t *mbs2wcs(char *mbs)
{
    static wchar_t *wcs= 0;
    static size_t bufSize= 0;
    size_t len= strlen(mbs) + 1;
    if (bufSize < len)
    {
	wcs= wcs ? (wchar_t *)realloc(wcs, sizeof(wchar_t) * len) : (wchar_t *)malloc(sizeof(wchar_t) * len);
	bufSize= len;
    }
    mbstowcs(wcs, mbs, bufSize);
    return wcs;
}

static char *wcs2mbs(wchar_t *wcs)
{
    static char *mbs= 0;
    static size_t bufSize= 0;
    size_t len= 6 * wcslen(wcs) + 1;
    if (bufSize < len) {
	mbs= mbs ? (char *)realloc(mbs, len) : (char *)malloc(len);
	bufSize= len;
    }
    wcstombs(mbs, wcs, bufSize);
    return mbs;
}


#if defined(__MACH__) && !defined(__MAC_10_7)

static wchar_t *wcsdup(wchar_t *s)
{
  size_t len= wcslen(s) + 1;
  wchar_t *t= malloc(sizeof(wchar_t) * len);
  if (t) wcscpy(t, s);
  return t;
}

#endif


#if 0

static void wperror(wchar_t *s)
{
    perror(wcs2mbs(s));
}

static FILE *wfopen(wchar_t *wpath, wchar_t *wmode)
{
    size_t pathlen= wcslen(wpath), modelen= wcslen(wmode);
    char *path= malloc(sizeof(wchar_t) * (pathlen + 1));  wcstombs(path, wpath, pathlen);
    char *mode= malloc(sizeof(wchar_t) * (modelen + 1));  wcstombs(mode, wmode, modelen);
    FILE *fp= fopen(path, mode);
    free(path);
    free(mode);
    return fp;
}

#endif
#+end_src

*** eval.l

The core module is eval.l. boot.l and emit.l are run after this.

#+begin_src lisp :noweb yes :mkdirp yes :tangle src/eval.l
(define-form gcdebug prog ())
;;(define-form gcd<D-F>ebug prog `(let () ,@prog))

(define-form debug prog ())
;;(define-form debug prog `(let () ,@prog))

(define-form safe prog ())
;;(define-form safe prog `(let () ,@prog))

(define-form if-tagged-int (a b) b)

(define-structure <header> (size flags next type))
(define-structure <buffer> (contents size position))

(define-function make-gc-protectors (vars)
  (map (lambda (v) (list 'gc_push_root (list 'address-of v)))
       vars))

(define-function make-gc-unprotectors (vars)
  (let ((result ()))
    (while (pair? vars)
      (set result (cons (list 'gc_pop_root (list 'address-of (car vars))) result))
      (set vars (cdr vars)))
    result))

(define-form gc-protect (vars . prog)
  `(let ()
     ,@(make-gc-protectors vars)
     (let ((__answer__ ,@prog))
       ,@(make-gc-unprotectors vars)
       __answer__)))

(define-function make-gc-let* (inits prog)
  (if (pair? inits)
      `((let (,(car inits)) (gc-protect (,(caar inits)) ,@(make-gc-let* (cdr inits) prog))))
    prog))

(define-form gc-let* (inits . prog) (car (make-gc-let* inits prog)))

(compile-begin)

(define abort		(extern	'abort))

(define exit		(extern	'exit))
(define malloc		(extern	'malloc))
(define realloc		(extern	'realloc))
(define free		(extern	'free))
(define memset		(extern	'memset))
(define memcpy		(extern	'memcpy))
(define memmove		(extern	'memmove))
(define printf		(extern	'printf))
(define fprintf		(extern	'fprintf))
(define sprintf		(extern	'sprintf))
(define snprintf	(extern	'snprintf))
(define isatty		(extern	'isatty))

(define arguments		0)
(define input			0)
(define stdin			0)
(define stdout			0)
(define stderr			0)

(define gc_quantum		(* 50 1024))
(define gc_frequency		32768)

(define gc_objects_live		0)
(define gc_bytes_used		0)
(define gc_bytes_free		0)

(define gc_roots		0)
(define gc_root_count		0)
(define gc_root_max		0)

(define gc_memory_base		0)
(define gc_memory_last		0)
(define gc_alloc_count		0)
(define gc_collection_count	0)

(define-form size-of-structure (type)	(* 4 (array-at %structure-sizes (eval type))))


(print "1\n")

(define-form <header>-flags-used ()	1)
(define-form <header>-flags-atom ()	2)
(define-form <header>-flags-mark ()	4)

(print "2\n")

(define-form <header>-flags-used+atom ()	(+ (<header>-flags-used) (<header>-flags-atom)))

(print "3\n")

(define-function max (a b)	(if (> a b) a b))

(define trace_stack	0)
(define trace_depth	0)

(define die) ;; forward

(define-function fatal (reason)		(printf "\neval.k: %s\n" reason) (exit 1))

(define-function fatal1 (fmt arg)	(printf "\neval.k: ") (printf fmt arg)		(printf "\n") (die))
(define-function fatal2 (fmt arg brg)	(printf "\neval.k: ") (printf fmt arg brg)	(printf "\n") (die))

(define-form k_error args
  `(let ()
     (printf "\neval.k: error: ")
     ,@(map (lambda (arg) (list (if (string? arg) 'printf 'k_print) arg)) args)
     (printf "\n")
     (die)))

(define-function new_memory_block (size)
  (let ((ptr (malloc size)))
    (or ptr (fatal "out of memory"))
    (set (<header>-size  ptr) (- size (size-of-structure <header>)))
    (set (<header>-flags ptr) 0)
    (set (<header>-next  ptr) ptr)
    (debug (printf "BRK %p %d %d/%d\n" ptr size gc_alloc_count gc_frequency))
    ptr))

(define-function gc_initialise ()
  (let ((ptr (new_memory_block gc_quantum)))
    (set gc_memory_base ptr)
    (set gc_memory_last ptr)))

(define-function gc_push_root (ptr)
  (and (= gc_root_count gc_root_max)
       (let* ((roots (malloc (* 4 (set gc_root_max (max 32 (* 2 gc_root_max)))))))
	 (memcpy roots gc_roots (* 4 gc_root_count))
	 (and gc_roots (free gc_roots))
	 (set gc_roots roots)))
  (set-oop-at gc_roots gc_root_count ptr)
  (debug (printf "gc PUSH root %d at %p\n" gc_root_count ptr))
  (set gc_root_count (+ 1 gc_root_count)))

(define-function gc_pop_root (ptr)
  (or gc_root_count (fatal "root table underflow"))
  (set gc_root_count (- gc_root_count 1))
  (debug (printf "gc POP  root %d at %p\n" gc_root_count ptr))
  (or (= ptr (oop-at gc_roots gc_root_count)) (fatal "non-lifo root")))

(define-function gc_grow_memory (size)
  (let ((brk (new_memory_block size)))
    (set (<header>-next brk) (<header>-next gc_memory_last))
    (set (<header>-next gc_memory_last) brk)))

(define-function gc_size (obj)	(<header>-size (- obj (size-of-structure <header>))))

(define-function gc_sweep ()
  (debug (printf "sweep\n"))
  (let ((ptr gc_memory_base)
	(nobjs 0)
	(nused 0)
	(nfree 0))
    (while ptr
      (debug (printf "sweep? %d %p + %d\n" (<header>-flags ptr) ptr (<header>-size ptr)))
      (let ((flags (<header>-flags ptr)))
	(if (& flags (<header>-flags-mark))
	    (let ()
	      (set nused (+ nused (<header>-size ptr)))
	      (set nobjs (+ nobjs 1))
	      (set (<header>-flags ptr) (^ flags (<header>-flags-mark))))
	  (debug (printf "collect %p %d\n" ptr (<header>-size ptr)))
	  (set nfree (+ nfree (<header>-size ptr)))
	  (set (<header>-flags ptr) 0)))
      (and (= gc_memory_base (set ptr (<header>-next ptr)))
	   (set ptr 0)))
    (set gc_objects_live nobjs)
    (set gc_bytes_used nused)
    (set gc_bytes_free nfree)
    (debug (printf "GC: %d used, %d free, %d allocations\n" nused nfree gc_alloc_count))
    ))

(define-function gc_mark_and_trace (obj)
  (and obj
       (not (& 1 obj))
       (let* ((ptr   (- obj (size-of-structure <header>)))
	      (flags (<header>-flags ptr)))
	 (debug (printf "mark and trace %p flags %d\n" obj flags))
	 (safe (or (& (<header>-flags-used) flags) (fatal1 "attempt to mark dead object %p" ptr)))
	 (or (& flags (<header>-flags-mark))
	     (let ()
	       (set (<header>-flags ptr) (| flags (<header>-flags-mark)))
	       (or (& flags (<header>-flags-atom))
		   (let ((size (>> (<header>-size ptr) 2)))
		     (debug (printf "mark %p %d type %d\n" ptr size (<header>-type ptr)))
		     (while size
		       (set size (- size 1))
		       (debug (printf "@%d %p\n" size (oop-at obj size)))
		       (gc_mark_and_trace (oop-at obj size))))))))))

(define-function gc_gcollect ()
  (gcdebug
    (or (& 1023 (set gc_collection_count (+ gc_collection_count 1)))
	(fprintf stderr "%d collections\n" gc_collection_count 1)))
  (let ((i 0))
    (while (< i gc_root_count)
      (debug (let ((ptr (oop-at gc_roots i))) (printf "mark gc root %d : %p -> %p\n" i ptr (oop-at ptr 0))))
      (gc_mark_and_trace (oop-at (oop-at gc_roots i) 0))
      (set i (+ 1 i))))
  (gc_sweep)
  (set gc_alloc_count 0))

(define-function gc_malloc (size)
  (set size (& -4 (+ 3 size)))
  (and (= gc_alloc_count gc_frequency) (gc_gcollect))
  (let* ((first (<header>-next gc_memory_last))
	 (chunk first)
	 (ssize (+ size (size-of-structure <header>))))
    (while 1
      (while
	(let ()
	  (debug (printf "alloc? %d %p %p [%p] %d >= %d %d\n" (<header>-flags chunk) chunk (<header>-next chunk) first (<header>-size chunk) size (<= size (<header>-size chunk))))
	  (if (= 0 (<header>-flags chunk))
	      (let ((csize (<header>-size chunk)))
		(while (and (= 0 (<header>-flags (<header>-next chunk)))
			    (= (<header>-next chunk) (+ chunk (+ (size-of-structure <header>) csize))))
		  (let ((next (<header>-next chunk)))
		    (set (<header>-next chunk) (<header>-next next))
		    (set csize (set (<header>-size chunk) (+ csize (+ (size-of-structure <header>) (<header>-size next)))))
		    (and (= next gc_memory_last) (set gc_memory_last chunk))))
		(if (or (< ssize csize) (= size csize))
		    (let ()
		      (debug (printf "csize %d\n" csize))
		      (and (> csize ssize)
			   (let ((split (+ chunk ssize)))
			     (debug (printf "split %d: %p + %d -> %p + %d\n" csize chunk size split (- csize (+ size (size-of-structure <header>)))))
			     (set (<header>-size  split) (- csize (+ size (size-of-structure <header>))))
			     (set (<header>-flags split) 0)
			     (set (<header>-next  split) (<header>-next chunk))
			     (set (<header>-size  chunk) size)
			     (set (<header>-next  chunk) split)
			     (set csize size)))
		      (set (<header>-flags chunk) (<header>-flags-used))
		      (set gc_memory_last chunk)
		      (debug (printf "alloc chunk %p\n" chunk))
		      (let ((obj (+ chunk (size-of-structure <header>))))
			(memset obj 0 csize)
			(set gc_alloc_count (+ gc_alloc_count 1))
			(return obj))))))
	  (!= first (set chunk (<header>-next chunk)))))
      (gc_grow_memory (max (+ (size-of-structure <header>) size) gc_quantum)))))

(define-function gc_malloc_atomic (size)
  (let* ((obj (gc_malloc size)))
    (set (<header>-flags (- obj (size-of-structure <header>))) (<header>-flags-used+atom))
    obj))

;;; ----------------------------------------------------------------

(define strlen	(extern 'strlen))
(define strcmp	(extern 'strcmp))
(define strdup	(extern 'strdup))
(define strtoul	(extern 'strtoul))
(define putc	(extern 'putc))
(define getc	(extern 'getc))
(define ungetc	(extern 'ungetc))
(define fopen	(extern 'fopen))
(define fdopen	(extern 'fdopen))
(define fclose	(extern 'fclose))
(define fflush	(extern 'fflush))
(define fscanf	(extern 'fscanf))

(define EOF	-1)
(define DONE	-4)	;; cannot be the same as a tagged immediate

(define <data>		 1)
(define <long>		 2)
(define <double>	 3)
(define <string>	 4)
(define <symbol>	 5)
(define <pair>		 6)
(define <_array>	 7)
(define <array>		 8)
(define <expr>		 9)
(define <form>		10)
(define <fixed>		11)
(define <subr>		12)
(define <variable>	13)
(define <env>		14)
(define <context>	15)


(define symbols			0)
(define globals			0)
(define expanders		0)
(define encoders		0)
(define evaluators		0)
(define applicators		0)
(define s_t			0)
(define s_dot			0)
(define s_define		0)
(define s_set			0)
(define s_lambda		0)
(define s_let			0)
(define s_quote			0)
(define s_quasiquote		0)
(define s_unquote		0)
(define s_unquote_splicing	0)
(define s_expanders		0)
(define s_encoders		0)
(define s_evaluators		0)
(define s_applicators		0)
(define f_set			0)
(define f_quote			0)
(define f_lambda		0)
(define f_let			0)
(define f_define		0)

(define opt_verbose		0)
(define opt_optimised		0)

(define-function new-bits (type size)
  (let ((obj (gc_malloc_atomic size)))
    (set (oop-at obj -1) type)
    obj))

(define-function new-oops (type size)
  (let ((obj (gc_malloc size)))
    (set (oop-at obj -1) type)
    obj))

(define-function new-<long> (bits)
  (if-tagged-int
    (| (<< bits 1) 1)
    (let ((obj (new-bits <long> (size-of-structure <long>))))
      (set (<long>-_bits obj) bits)
      obj)))

(define-function _new-<string> (len)
  (let ((str (new-oops <string> (size-of-structure <string>))))
    (gc-protect (str)
      (set (<string>-size  str) (new-<long> len))
      (set (<string>-_bits str) (gc_malloc_atomic (+ len 1)))
      str)))

(define-function new-<string> (cstr)
  (let ((len (strlen cstr)))
    (let ((obj (_new-<string> len)))
      (memcpy (<string>-_bits obj) cstr len)
      obj)))

(define-function new-<symbol> (cstr)
  (let ((obj (new-bits <symbol> (size-of-structure <symbol>))))
    (set (<symbol>-_bits obj) (strdup cstr))
    obj))

(define-function new-<pair> (head tail)
  (let ((obj (new-oops <pair> (size-of-structure <pair>))))
    (set (<pair>-head obj) head)
    (set (<pair>-tail obj) tail)
    obj))

(define-function new-<array> (size)
  (let ((cap (if size size 1))
	(arr (new-oops <array> (size-of-structure <array>))))
    (gc-protect (arr)
		(set (<array>-size   arr) (new-<long> size))
      (set (<array>-_array arr) (new-oops <_array> (* 4 cap)))
      arr)))

(define-function new-<expr> (defn ctx)
  (let ((obj (new-oops <expr> (size-of-structure <expr>))))
    (set (<expr>-defn obj) defn)
    (set (<expr>-ctx  obj) ctx)
    obj))

(define-function new-<form> (fn sym)
  (let ((obj (new-oops <form> (size-of-structure <form>))))
    (gc-protect (obj)
      (set (<form>-function obj) fn)
      (set (<form>-symbol   obj) sym)
      obj)))

(define-function new-<fixed> (fn)
  (let ((obj (new-oops <fixed> (size-of-structure <fixed>))))
    (gc-protect (obj)
      (set (<fixed>-function obj) fn)
      obj)))

(define-function new-<subr> (_imp _name)
  (let ((obj (new-bits <subr> (size-of-structure <subr>))))
    (gc-protect (obj)
      (set (<subr>-_imp  obj) _imp)
      (set (<subr>-_name obj) _name)
      obj)))

(define-function new-<variable> (name value env index)
  (let ((obj (new-oops <variable> (size-of-structure <variable>))))
    (gc-protect (obj)
      (set (<variable>-name  obj) name)
      (set (<variable>-value obj) value)
      (set (<variable>-env   obj) env)
      (set (<variable>-index obj) (new-<long> index))
      obj)))

(define-form get-type (arg)
  `(let ((__arg__ ,arg))
     (safe (and __arg__ (not (& __arg__ 1))
		(or (& (<header>-flags-used) (<header>-flags (- __arg__ (size-of-structure <header>))))
		    (fatal1 "attempt to access dead object %p type %d" __arg__))))
     (if __arg__
	 (if (& __arg__ 1)
	     <long>
	   (oop-at __arg__ -1))
       <undefined>)))

(define-form is (type arg)
  `(= ,type (get-type ,arg)))

(define-function type_check_fail (exp act)
  (fatal2 "illegal type: expected %d got %d" exp act))

(define-form get (type field object)
  `(let ((__obj__ ,object))
     (safe (let ((t (get-type __obj__))) (or (= ,type t) (type_check_fail ,type t))))
     (,(concat-symbol (concat-symbol type '-) field) __obj__)))

(define-form put (type field object value)
  `(let ((__obj__ ,object))
     (safe (let ((t (get-type __obj__))) (or (= ,type t) (type_check_fail ,type t))))
     (set (,(concat-symbol (concat-symbol type '-) field) __obj__) ,value)))

(define-form is_long(obj)	(if-tagged-int	`(&  ,obj 1)	`(is <long> ,obj)))
(define-form get_long (obj)	(if-tagged-int	`(>> ,obj 1)	`(get <long> _bits ,obj)))

(define-form get_head (obj)	`(oop-at ,obj 0))
(define-form get_tail (obj)	`(oop-at ,obj 1))
(define-form set_head (obj val)	`(set-oop-at ,obj 0 ,val))
(define-form set_tail (obj val)	`(set-oop-at ,obj 1 ,val))

(define-function new-<env> (parent level offset)
  (let ((obj (new-oops <env> (size-of-structure <env>))))
    (gc-protect (obj)
      (set (<env>-parent   obj) parent)
      (set (<env>-level    obj) (new-<long> (if parent (+ (get_long (get <env> level parent)) level) 0)))
      (set (<env>-offset   obj) (new-<long> offset))
      (set (<env>-bindings obj) (new-<array> 0))
      obj)))

(define-function new-base-<context> (home caller env)
  (let ((obj (new-oops <context> (size-of-structure <context>))))
    (gc-protect (obj)
      (set (<context>-home     obj) home)
      (set (<context>-env      obj) env)
      (set (<context>-bindings obj) (new-<array> 0))
      obj)))

;; (define-function new-<context> (home caller env)
;;   (let ((obj (new-oops <env> (size-of-structure <context>))))
;;     (gc-protect (obj)
;;       (set (<context>-home     obj) home)
;;       (set (<context>-env      obj) env)
;;       (set (<context>-bindings obj) (new-<array> 0))
;;       obj)))

(define-function new-<context> (home caller env)
  (let ((obj ()))
    (if (and caller (set obj (get <context> callee caller)))
	(let ()
	  (put <context> home obj home)
	  (put <context> env  obj env))
      (set obj (new-base-<context> home caller env))
      (and caller (put <context> callee caller obj)))
    obj))

(define-function is_global (var)
  (let ((env (get <variable> env var)))
    (and env (= 0 (get_long (get <env> level env))))))

;;; ----------------------------------------------------------------

(define-function k_car (list)	(and (is <pair> list) (get_head list)))
(define-function k_cdr (list)	(and (is <pair> list) (get_tail list)))

(define-function k_caar (list)	(k_car (k_car list)))
(define-function k_cadr (list)	(k_car (k_cdr list)))
(define-function k_cddr (list)	(k_cdr (k_cdr list)))

(define-function k_caddr (list)	(k_car (k_cdr (k_cdr list))))

(define-function k_string_length (obj)	(get_long (get <string> size obj)))

(define-function k_concat (head tail)
  (if (is <pair> head)
      (let ()
	(set tail (k_concat (get_tail head) tail))
	(gc-protect (tail)
	  (new-<pair> (get_head head) tail)))
    tail))

(define-function k_array_length (obj)
  (get_long (get <array> size obj)))

(define-function k_array_at (obj idx)
  (and (is <array> obj)
       (let* ((elts (get <array> _array obj))
	      (size (get_long (get <array> size obj))))
	 (and (<= 0 idx) (< idx size)
	      (oop-at elts idx)))))

(define-function k_set_array_at (obj idx val)
  (and (is <array> obj)
       (let* ((elts (get <array> _array obj))
	      (size (get_long (get <array> size obj))))
	 (and (<= 0 idx)
	      (let ()
		(or (< idx size)
		    (let ((cap (/ (gc_size elts) 4)))
		      (while (<= cap idx) (set cap (* cap 2)))
		      (gc-protect (obj)
		        (let ((oops (new-oops <_array> (* 4 cap))))
			  (memcpy oops elts (* size 4))
			  (set elts (put <array> _array obj oops)))
			(put <array> size obj (new-<long> (+ 1 idx))))))
		(set-oop-at elts idx val))))))

(define-function k_array_append (array val)
  (k_set_array_at array (k_array_length array) val))

(define-function k_array_insert (obj index value)
  (let ((len (k_array_length obj)))
    (k_array_append obj value)
    (and (< index len) 
	 (let* ((elts (get <array> _array obj))
		(oops (+ elts (* 4 index))))
	   (memmove (+ 4 oops) oops (* 4 (- len index))))))
  (k_set_array_at obj index value))

(define-function do_print (obj storing)
  (debug (printf "{%p}" obj))
  (let ((type (get-type obj)))
    (cond
      ((= type <undefined>)	(printf "nil"))
      ((= type <long>)		(printf "%d" (get_long obj)))
      ((= type <string>)	(let ((bits (get <string> _bits obj)))
				  (if (not storing)
				      (printf "%s" bits)
				    (let ((i 0)
					  (c 0))
				      (printf "\"")
				      (while (set c (string-at bits i))
					(if (and (<= 32 c) (<= c 126))
					    (cond
					      ((= c ?\")	(printf "\\\""))
					      ((= c ?\\)	(printf "\\\\"))
					      (else		(printf "%c" c)))
					  (printf "\\%03o" c))
					(set i (+ 1 i)))
				      (printf "\"")))))
      ((= type <symbol>)	(printf "%s" (get <symbol> _bits obj)))
      ((= type <pair>)		(let ()
				  (printf "(")
				  (while (and (is <pair> obj) (!= globals obj))
				    (do_print (get_head obj) storing)
				    (and (is <pair> (set obj (get_tail obj))) (printf " ")))
				  (if (= globals obj)
				      (printf "<globals>")
				    (and obj
					 (let ()
					   (printf " . ")
					   (do_print obj storing))))
				  (printf ")")))
      ((= type <array>)		(let ((len (k_array_length obj)))
				  (printf "Array(")
				  (for (i 0 len)
				    (and i (printf " "))
				    (do_print (k_array_at obj i)))
				  (printf ")")))
      ((= type <expr>)		(let ()
				  (printf "Expr(")
				  (do_print (k_car (get <expr> defn obj)) storing)
				  (printf ")")))
      ((= type <form>)		(let ()
				  (printf "Form(")
				  (do_print (get <form> function obj) storing)
				  (printf ",")
				  (do_print (get <form> symbol   obj) storing)
				  (printf ")")))
      ((= type <fixed>)		(let ()
				  (printf "Fixed(")
				  (do_print (get <fixed> function obj) storing)
				  (printf ")")))
      ((= type <subr>)		(printf "Subr(%s)" (get <subr> _name obj)))
      ((= type <variable>)	(let ((env (get <variable> env obj)))
 				  (do_print (get <variable> name obj))
				  (and env
				       (printf ".%d+%d"
					       (get_long (get <env> level (get <variable> env obj)))
					       (get_long (get <variable> index obj))))))
      ((= type <env>)		(let ()
 				  (printf "Env<%d>" (get_long (get <env> level obj)))))
      ((= type <context>)	(let ()
				  (printf "Context<>")))
      (else			(printf "<type:%d>" type)))))

(define-function k_print (obj) (do_print obj 0))	(define-function k_println (obj) (do_print obj 0) (printf "\n"))
(define-function k_dump  (obj) (do_print obj 1))	(define-function k_dumpln  (obj) (do_print obj 1) (printf "\n"))

(set die (lambda ()
	   (let ((i trace_depth))
	     (while (<= 0 (set i (- i 1)))
	       (printf "%3d: " i)
	       (k_dumpln (k_array_at trace_stack i))))
	   (exit 1)))

;;; ----------------------------------------------------------------

(define-function is_blank (c)	(or 	 ( = ?   c)			; sp
				    	 ( = ?\t c)			; ht
				    	 ( = ?\n c)			; nl
				    	 ( = ?\v c)			; vt
				    	 ( = ?\f c)			; ff
				    	 ( = ?\r c)))			; cr

(define-function is_digit10 (c)	    (and (<= ?0  c) (<= c ?9)))		; 0 1 2 3 4 5 6 7 8 9

(define-function is_digit16 (c)	(or (and (<= ?0  c) (<= c ?9))		; 0 1 2 3 4 5 6 7 8 9
				    (and (<= ?a  c) (<= c ?f))		; a b c d e f
				    (and (<= ?A  c) (<= c ?F))))	; A B C D E F

(define-function is_alpha (c)	(or (and (<= ?a  c) (<= c ?z))		; a b c d e f g h i j k l m n o p q r s t u v w x y z
				    (and (<= ?A  c) (<= c ?Z))))	; A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

(define-function is_letter (c)	(or      ( = ?!  c)			; !
				    (and (<= ?#  c) (<= c ?&))		; # $ % &
				    (and (<= ?*  c) (<= c ?/))		; * + , - . /
					 ( = ?:  c)			; :
				    (and (<= ?<  c) (<= c ?Z))		; < = > ?  @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
					 ( = ?\\ c)			; \
					 ( = ?^  c)			; ^
					 ( = ?_  c)			; _
				    (and (<= ?a  c) (<= c ?z))		; a b c d e f g h i j k l m n o p q r s t u v w x y z
					 ( = ?|  c)			; |
					 ( = ?~  c)			; ~
					 (<= 128 c)))			; utf-8 multibyte character

(define-function new_buffer ()
  (let ((buf (malloc (size-of-structure <buffer>))))
    (set (<buffer>-contents buf) (malloc 32))
    (set (<buffer>-size     buf) 32)
    (set (<buffer>-position buf) 0)
    buf))

(define-function buffer_delete (buf)
  (free (<buffer>-contents buf))
  (free buf))

(define-function buffer_grow (buf)
  (let* ((size     (<buffer>-size buf))
	 (contents (malloc (* 2 size))))
    (memcpy contents (<buffer>-contents buf) size)
    (free (<buffer>-contents buf))
    (set (<buffer>-contents buf) contents)
    (set (<buffer>-size buf) (* 2 size))))

(define-function buffer_append (buf c)
  (and (= (<buffer>-position buf) (<buffer>-size buf))
       (buffer_grow buf))
  (let ((posn (<buffer>-position buf)))
    (set-string-at (<buffer>-contents buf) posn c)
    (set (<buffer>-position buf) (+ 1 posn))))

(define-function buffer_append_all (buf s)
  (let ((i 0)
	(c 0))
    (while (set c (string-at s i))
      (buffer_append buf c)
      (set i (+ 1 i)))))

(define-function buffer_contents (buf)
  (buffer_append buf 0)
  (set (<buffer>-position buf) (- (<buffer>-position buf) 1))
  (<buffer>-contents buf))

(define-function intern (string)
  (let ((lo 0)
	(hi (- (k_array_length symbols) 1)))
    (while (<= lo hi)
      (let* ((m (/ (+ lo hi) 2))
	     (s (k_array_at symbols m))
	     (c (strcmp string (get <symbol> _bits s))))
	(cond
	  ((< c 0)	(set hi (- m 1)))
	  ((> c 0)	(set lo (+ m 1)))
	  (else		(return s)))))
    (gc-let* ((s (new-<symbol> string)))
      (k_array_insert symbols lo s))))

(define-function is_octal (c)		(and (<= ?0 c) (<= c ?7)))

(define-function is_hexadecimal (c)	(or (and (<= ?0 c) (<= c ?9))
					    (and (<= ?a c) (<= c ?f))
					    (and (<= ?A c) (<= c ?F))))

(define-function digit_value (c)
  (cond
    ((and (<= ?0 c) (<= c ?9))	(- c ?0))
    ((and (<= ?a c) (<= c ?z))	(- c (- ?a 10)))
    ((and (<= ?A c) (<= c ?Z))	(- c (- ?A 10)))
    (else			(fatal "illegal digit in character escape"))))

(define-function read_char (c stream)
  (if (= ?\\ c)
      (let ()
	(set c (getc stream))
	(cond
	  ((= c ?a)			?\a)
	  ((= c ?b)			?\b)
	  ((= c ?f)			?\f)
	  ((= c ?n)			?\n)
	  ((= c ?r)			?\r)
	  ((= c ?t)			?\t)
	  ((= c ?v)			?\v)
	  ((= c ?u)			(let ((a (getc stream))
					      (b (getc stream))
					      (c (getc stream))
					      (d (getc stream)))
					  (+ (<< (digit_value a) 24)
					     (+ (<< (digit_value b) 16)
						(+ (<< (digit_value c)  8)
						   (digit_value d)    )))))
	  ((= c ?x)			(let ((x 0))
					  (if (is_hexadecimal (set c (getc stream)))
					      (let ()
						(set x (digit_value c))
						(if (is_hexadecimal (set c (getc stream)))
						    (let ()
						      (set x (+ (* x 16) (digit_value c)))
						      (set c (getc stream))))))
					  (ungetc c stream)
					  x))
	  ((and (<= ?0 c) (<= c ?7))	(let ((x (digit_value c)))
					  (if (is_octal (set c (getc stream)))
					      (let ()
						(set x (+ (* x 8) (digit_value c)))
						(if (is_octal (set c (getc stream)))
						    (let ()
						      (set x (+ (* x 8) (digit_value c)))
						      (set c (getc stream))))))
					  (ungetc c stream)
					  x))
	  (else			(if (or (is_alpha c) (is_digit10 c))
				    (fatal1 "illegal character escape: \\%c" c)
				  c))))
    c))

(define-function read_number (c stream)
  (let ((buf (new_buffer))
	(neg (= ?- c)))
    (or neg (buffer_append buf c))
    (while (is_digit10 (set c (getc stream))) (buffer_append buf c))
    (and (= ?x c) (= 1 (<buffer>-position buf))
	 (let ()
	   (buffer_append buf c)
	   (while (is_digit16 (set c (getc stream))) (buffer_append buf c))))
    (ungetc c stream)
    (buffer_append buf 0)
    (let ((result (strtoul (<buffer>-contents buf) 0 0)))
      (buffer_delete buf)
      (new-<long> (if neg (- result) result)))))

(define-function read_symbol (c stream)
  (let ((buf (new_buffer)))
    (while (or (is_letter c) (is_digit10 c))
      (buffer_append buf c)
      (set c (getc stream)))
    (ungetc c stream)
    (buffer_append buf 0)
    (let ((result (intern (<buffer>-contents buf))))
      (buffer_delete buf)
      result)))

(define-function read_string (c stream)
  (let ((buf (new_buffer)))
    (while (!= ?\" (set c (getc stream)))
      (set c (read_char c stream))
      (and (= EOF c) (fatal "unterminated string literal"))
      (buffer_append buf c))
    (buffer_append buf 0)
    (let ((result (new-<string> (<buffer>-contents buf))))
      (buffer_delete buf)
      result)))

(define k_read) ;; forward

(define-function read_list (delim stream)
  (let* ((head (new-<pair> () ()))
	 (tail head)
	 (elt  ()))
    (gc-protect (head elt)
      (while (and (!= DONE (set elt (k_read stream))) (!= s_dot elt))
	(set elt (new-<pair> elt ()))
	(set tail (set_tail tail elt)))
      (and (= s_dot elt) (set_tail tail (k_read stream))))
    (let ((c (getc stream)))
      (if (= delim c)
	  (get_tail head)
	(fatal1 "missing closing '%c' delimiter while reading list" delim)))))

(define-function read_quote (prefix stream)
  (let ((qobj (k_read stream)))
    (and (= DONE qobj) (fatal "EOF while reading quoted literal"))
    (gc-protect (qobj)
      (set qobj (new-<pair> qobj ()))
      (set qobj (new-<pair> prefix qobj))
      qobj)))

(set k_read (lambda (stream)
  (while 1
    (let ((c (getc stream)))
      (cond
	((is_blank c)	())
	((= ?? c)	(return (new-<long> (read_char (getc stream) stream))))
	((= ?- c)	(return (if (is_digit10 (ungetc (getc stream) stream))
				    (read_number c stream)
				    (read_symbol c stream))))
	((= ?\' c)	(return (read_quote s_quote stream)))
	((= ?\` c)	(return (read_quote s_quasiquote stream)))
	((= ?\, c)	(return (let ((d (getc stream)))
				  (if (= ?@ d)
				      (read_quote s_unquote_splicing stream)
				    (ungetc d stream)
				    (read_quote s_unquote)))))
	((is_letter c)	(return (read_symbol c stream)))
	((= ?\( c)	(return (read_list ?\) stream)))	((= ?\) c)	(return (let () (ungetc c stream) DONE)))
	((= ?\[ c)	(return (read_list ?\] stream)))	((= ?\] c)	(return (let () (ungetc c stream) DONE)))
	((= ?\{ c)	(return (read_list ?\} stream)))	((= ?\} c)	(return (let () (ungetc c stream) DONE)))
	((is_digit10 c)	(return (read_number c stream)))
	((= ?\; c)	(while (and (!= ?\n (set c (getc stream)))
				    (!= ?\r c)
				    (!= EOF c))))
	((= ?\" c)	(return (read_string c stream)))
	((< c 0)	(return DONE))
	(else		(fatal1 "illegal character: %c" c)))))))

;;; ----------------------------------------------------------------

(define-function k_env_find_variable (env name)
  (while env
    (let* ((bindings (get <env> bindings env))
	   (index    (k_array_length bindings))
	   (vars     (get <array> _array bindings)))
      (while (<= 0 (set index (- index 1)))
	(let ((var (oop-at vars index)))
	  (and (= name (get <variable> name var))
	       (return var)))))
    (set env (get <env> parent env))))

(define-function k_env_lookup (env name)
  (let ((var (k_env_find_variable env name)))
    (if var
	(get <variable> value var)
      (fatal1 "undefined variable: %s" (get <symbol> _bits name)))))

(define-function k_env_define (env name value)
  (let* ((bindings (get <env> bindings env))
	 (index (k_array_length bindings)))
    (while (>= (set index (- index 1)) 0)
      (let ((var (k_array_at bindings index)))
	(and (= name (get <variable> name var))
	     (let ()
	       (put <variable> value var value)
	       (return var)))))
    (let* ((off (get_long (get <env> offset env)))
	   (var (new-<variable> name value env off)))
      (gc-protect (var)
	(put <env> offset env (new-<long> (+ off 1)))
	(k_array_append bindings var)))))

;;; ----------------------------------------------------------------

; Good ol' eval / apply with the semantics for coke

(define k_eval) ;; forward

(define-function k_apply_expr (fun arguments ctx)
  (and (< 2 opt_verbose) (let () (printf "  A  ")  (k_dump fun)  (printf " ")  (k_dump arguments) (printf " ")  (k_dumpln ctx) (fflush stdout)))
  (let* ((args    arguments)
	 (defn    (get <expr> defn fun))
	 (env     (k_car defn))
	 (formals (k_cadr defn)))
    (set ctx (new-<context> (get <expr> ctx fun) ctx env))
    (let ((locals (get <context> bindings ctx)))
      (gc-protect (defn ctx)
        (while (is <pair> formals)
	  (or (is <pair> args) (k_error "too few arguments: ("fun" "arguments")"))
	  (k_set_array_at locals (get_long (get <variable> index (get_head formals))) (get_head args))
	  (set formals (get_tail formals))
	  (set args    (get_tail args)))
	(and (is <variable> formals)
	     (let ()
	       (k_set_array_at locals (get_long (get <variable> index formals)) args)
	       (set args ())))
	(and args (k_error "too many arguments: ("fun" "arguments")"))
	(set defn (get_tail (get_tail defn)))
	(while (is <pair> defn)
	  (set args (k_eval (get_head defn) ctx))
	  (set defn (get_tail defn)))
	(and (get <env> stable env) (put <context> callee ctx ()))
	args))))

(define counter 0)

(define-function k_apply (fun arguments ctx)
  ;;(printf "  %02d " trace_depth) (k_dumpln fun)
  (let ((type (get-type fun)))
    (cond
      ((= type <expr>)		(k_apply_expr fun arguments ctx))
      ((= type <fixed>)		(k_apply (get <fixed> function fun) arguments ctx))
      ((= type <subr>)		((get <subr> _imp fun) arguments ctx))
      (else			(let ((ap (k_array_at (get <variable> value applicators) (get-type fun))))
				  (if ap
				      (let ((args arguments))
					(gc-protect (args)
					  (set args (new-<pair> fun args))
					  (k_apply ap args ctx)))
				    (k_error "cannot apply: " fun)))))))

;;; ----------------------------------------------------------------

(define exlist) ;; forward

(define-function k_expand (exp env)
  (if (is <pair> exp)
      (let ((head (k_expand (get_head exp) env)))
	(gc_push_root (address-of head))
	(if (is <symbol> head)
	    (let ((val (k_env_find_variable env head)))
	      (and (is <variable> val) (set val (get <variable> value val)))
	      (and (is <form> val)
		   (let ((fn (get <form> function val)))
		     (and fn
			  (let ((args (new-<pair> env (get_tail exp))))
			    (gc-protect (args)
					(set head (k_apply fn args ()))
					(set head (k_expand head env)))
			    (gc_pop_root (address-of head))
			    (return head)))))))
	(let ((tail (get_tail exp)))
	  (gc_push_root (address-of tail))
	  (or (= head s_quote) (set tail (exlist tail env)))
	  (and (= s_set head)
	       (is <pair>   (k_car  tail))
	       (is <symbol> (k_caar tail))
	       (let ((buf (new_buffer)))
		 (buffer_append_all buf "set-")
		 (buffer_append_all buf (get <symbol> _bits (get_head (get_head tail))))
		 (set head (intern (buffer_contents buf)))
		 (set tail (k_concat (get_tail (get_head tail)) (get_tail tail)))))
	  (set exp (new-<pair> head tail))
	  (gc_pop_root (address-of tail))
	  (gc_pop_root (address-of head))))
    (if (is <symbol> exp)
	(let ((val (k_env_find_variable env exp)))
	  (and (is <variable> val) (set val (get <variable> value val)))
	  (and (is <form> val)
	       (let ((fn (get <form> symbol val)))
		 (and fn
		      (let ((args (new-<pair> exp ())))
			(gc-protect (args)
				    (set args (new-<pair> env args))
				    (set args (k_apply fn args ()))
				    (set exp (k_expand args env))))))))
      (let ((fn (k_array_at (get <variable> value expanders) (get-type exp))))
	(and fn
	     (let ((args (new-<pair> exp ())))
	       (gc-protect (args)
			   (set exp (k_apply fn args ()))))))))
  exp)

(set exlist (lambda (list env)
  (if (is <pair> list)
      (let ((head (k_expand (get_head list) env)))
	(gc-protect (head)
	  (let ((tail (exlist (get_tail list) env)))
	    (gc-protect (tail)
	      (new-<pair> head tail)))))
    (k_expand list env))))

(define enlist) ;; forward

(define-function k_encode (exp env)
  (if (is <pair> exp)
      (let ((head (k_encode (get_head exp) env))
	    (tail (get_tail exp)))
	(gc-protect (head tail)
	  (cond
	    ((= head f_let)		(let ((args (k_cadr exp)))
					  (gc-protect (env)
					    (set env (new-<env> env 0 (get_long (get <env> offset env))))
					    (while (is <pair> args)
					      (let ((var (get_head args)))
						(and (is <pair> var) (set var (get_head var)))
						(k_env_define env var ())
						(set args (get_tail args))))
					    (set tail (enlist tail env))
					    (set tail (new-<pair> env tail)))))
	    ((= head f_lambda)		(let ((args (k_cadr exp)))
					  (gc-protect (env)
					    (set env (new-<env> env 1 0))
					    (while (is <pair> args)
					      (k_env_define env (get_head args) ())
					      (set args (get_tail args)))
					    (and args (k_env_define env args ()))
					    (set tail (enlist tail env))
					    (set tail (new-<pair> env tail)))))
	    ((= head f_define)		(let ((var (k_env_define (get <variable> value globals) (k_car tail) ())))
					  (set tail (enlist (k_cdr tail) env))
					  (set tail (new-<pair> var tail))))
	    ((= head f_set)		(let ((var (k_env_find_variable env (k_car tail))))
					  (or var (fatal1 "set: undefined variable: %s" (get <symbol> _bits (k_car tail))))
					  (set tail (enlist (k_cdr tail) env))
					  (set tail (new-<pair> var tail))))
	    ((!= head f_quote)		(set tail (enlist tail env))))
	  (set exp (new-<pair> head tail))))
    (if (is <symbol> exp)
	(let ((val (k_env_find_variable env exp)))
	  (or val (fatal1 "undefined variable: %s" (get <symbol> _bits exp)))
	  (set exp val)
	  (if (is_global exp)
	      (let ((v (get <variable> value exp)))
		(and (or (is <form> v) (is <fixed> v))
		     (set exp v)))
	    (let ((venv (get <variable> env exp)))
	      (or (= (get_long (get <env> level venv)) (get_long (get <env> level env)))
		  (put <env> stable venv s_t)))))
      (let ((fn (k_array_at (get <variable> value encoders) (get-type exp))))
	(and fn (let () (printf "APPLY GOT ENCODER\n... " (k_println fn) 1)))
	(and fn
	     (let ((args (new-<pair> env ())))
	       (gc-protect (args)
			   (set args (new-<pair> exp args))
			   (printf "APPLY ENCODER\n... ") (k_print fn) (printf " ") (k_print args) (printf " ") (k_println env)
			   (set exp (k_apply fn args ()))))))))
  exp)

(set enlist (lambda (list env)
  (if (is <pair> list)
      (let ((head (k_encode (get_head list) env)))
	(gc-protect (head)
	  (let ((tail (enlist (get_tail list) env)))
	    (gc-protect (tail)
	      (new-<pair> head tail)))))
    (k_encode list env))))



; evlis from the lisp 1.5 manual

(define-function evlist (obj ctx)
  (if (is <pair> obj)
      (let ((head (k_eval (get_head obj) ctx)))
	(gc-protect (head)
	  (let ((tail (evlist (get_tail obj) ctx)))
	    (gc-protect (tail)
	      (new-<pair> head tail)))))
    obj))

; finally eval

(set k_eval (lambda (exp ctx)
  (and (< 2 opt_verbose) (let () (printf "  E  ")  (k_dump exp)  (printf " ") (k_dumpln ctx)  (fflush stdout)))
  (let ((type (get-type exp)))
    (cond
      ((= type <undefined>)	exp)
      ((= type <long>)		exp)
      ((= type <string>)	exp)
      ((= type <variable>)	(if (is_global exp)
				    (get <variable> value exp)
				  (let ((delta (- (get_long (get <env> level (get <context>  env ctx)))
						  (get_long (get <env> level (get <variable> env exp))))))
				    (while (< 0 delta)
				      (set ctx (get <context> home ctx))
				      (set delta (- delta 1)))
				    (k_array_at (get <context> bindings ctx) (get_long (get <variable> index exp))))))
      ((= type <pair>)		(let ((head (k_eval (get_head exp) ctx)))
				  (gc-protect (head)
				    (k_set_array_at trace_stack trace_depth exp)
				    (set trace_depth (+ trace_depth 1))
				    (set head (if (is <fixed> head)
						  (k_apply (get <fixed> function head) (get_tail exp) ctx)
						(let ((args (evlist (get_tail exp) ctx)))
						  (gc-protect (args)
						    (k_apply head args ctx)))))
				    (set trace_depth (- trace_depth 1))
				    head)))
      ((= type <symbol>)	(k_error "symbol in eval?")) ;; xxx
      (else			(let ((ev (k_array_at (get <variable> value evaluators) (get-type exp))))
				  (and ev
				       (let ((args (new-<pair> exp ())))
					 (gc-protect (args)
					   (k_set_array_at trace_stack trace_depth exp)
					   (set trace_depth (+ trace_depth 1))
					   (set exp (k_apply ev args ctx))
					   (set trace_depth (- trace_depth 1)))))
				  exp))))))

(define-function subr_define (args ctx)
  (let ((var (k_car args)))
    (or (is <variable> var)
	(let ()
	  (printf "\nerror: non-variable in define: ")
	  (k_dumpln var)
	  (fatal "aborting")))
    (let ((val (k_eval (k_cadr args) ctx)))
      (put <variable> value var val))))

(define-function subr_definedP (args ctx)
  (let ((s (k_car args))
	(e (or (k_cadr args) (get <variable> value globals))))
    (k_env_find_variable e s)))

(define-function subr_lambda (args ctx)
  (new-<expr> args ctx))

(define-function subr_let (args ctx)
  (let* ((tmp      ())
	 (bindings (k_cadr args))
	 (locals   (get <context> bindings ctx))
	 (body     (k_cddr args)))
    (gc-protect (tmp)
      (while (is <pair> bindings)
	(let ((binding (get_head bindings)))
	  (if (is <pair> binding)
	      (let ((var  (get_head binding))
		    (prog (get_tail binding)))
		(set tmp ())
		(while (is <pair> prog)
		  (set tmp (k_eval (get_head prog) ctx))
		  (set prog (get_tail prog)))
		(k_set_array_at locals (get_long (get <variable> index var)) tmp))))
	(set bindings (get_tail bindings)))
      (set tmp ())
      (while (is <pair> body)
	(set tmp (k_eval (get_head body) ctx))
	(set body (get_tail body))))
    tmp))

(define-function subr_set (args ctx)
  ;;(printf "SET ") (k_print args) (printf " IN ") (k_println ctx)
  (let ((var (k_car args)))
    (or (is <variable> var)
	(let ()
	  (printf "\ncannot set undefined variable: ")
	  (k_dumpln var)
	  (fatal "aborting")))
    (let ((val (k_eval (k_cadr args) ctx)))
      (if (is_global var)
	  (put <variable> value var val)
	(let ((delta (- (get_long (get <env> level (get <context>  env ctx)))
			(get_long (get <env> level (get <variable> env var))))))
	  (while (< 0 delta)
	    (set ctx (get <context> home ctx))
	    (set delta (- delta 1)))
	  (k_set_array_at (get <context> bindings ctx) (get_long (get <variable> index var)) val))))))

(define-function subr_while (args ctx)
  (let ((tst  (k_car args))
	(prog args))
    (while (k_eval tst ctx)
      (let ((body prog))
	(while (is <pair> (set body (k_cdr body)))
	  (k_eval (get_head body) ctx))))))

(define-function subr_if (args ctx)
  (if (k_eval (k_car args) ctx)
      (k_eval (k_cadr args) ctx)
    (let ((ans ()))
      (set args (k_cdr args))
      (while (is <pair> (set args (k_cdr args)))
	(set ans (k_eval (get_head args) ctx)))
      ans)))

(define-function subr_or (args ctx)
  (let ((ans ()))
    (while (is <pair> args)
      (and (set ans (k_eval (get_head args) ctx))
	   (return ans))
      (set args (get_tail args)))))

(define-function subr_and (args ctx)
  (let ((ans s_t))
    (while (is <pair> args)
      (or (set ans (k_eval (get_head args) ctx))
	  (return ()))
      (set args (get_tail args)))
    ans))

(define-function subr_quote (args ctx)
  (k_car args))

(define-function subr_not (args ctx)
  (if (k_car args) () s_t))

(define-function arity2 (op args)
  (or (and (is <pair> args)
	   (is <pair> (get_tail args))
	   (= () (get_tail (get_tail args))))
      (fatal1 "%s: expected 2 arguments" op)))

(define-function arity3 (op args)
  (or (and (is <pair> args)
	   (is <pair> (get_tail args))
	   (is <pair> (get_tail (get_tail args)))
	   (= () (get_tail (get_tail (get_tail args)))))
      (fatal1 "%s: expected 3 arguments" op)))

(define-function subr_sub (args ctx)
  (or args (fatal "-: expected 1 or 2 arguments"))
  (let ((lhs (get_head args))
	(rhs (get_tail args)))
    (if (and (is <pair> rhs))
	(let ()
	  (set rhs (get_head rhs))
	  (if (and (is_long lhs) (is_long rhs))
	      (new-<long> (- (get_long lhs) (get_long rhs)))
	    (k_error "non-numeric argument: (- "lhs" "rhs")")))
      (if (and (is_long lhs))
	  (new-<long> (- (get_long lhs)))
	(k_error "non-numeric argument: (- "lhs")")))))



;; Const
;; values of Operator
;; predefined communication messages
(define-constant any-message           "ANY")
(define-constant finish-message        "FINISH")

(define-constant hidden-name-prefix    "@")

;; can use new-<long> 32bit/64bit number
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Integer-Basics.html
;;
(define infinite              max(<long>))

;; Type
;; https://stackoverflow.com/questions/23493877/percent-sign-in-defun-and-defstruct
;; % represents an internal function
;; Classes don't exist here, but we do have multi-methods, so struct+constructorFn+overloadedMethods
;; <node> refers to supplying a node variable in that slot
;; Oberon class vars-> structure params here
;; https://www.tutorialspoint.com/lisp/lisp_returning_values_functions.htm
;; By default, a function in LISP returns the val of the last expression evaluated as the return val
;; define-structure etc use dynamic typing
;; node inherits from Object
(define-structure <node> (position attr-list)) ;; long identifier-list
(define-function new-node (position) ;; long
  (let ((self (new <node>)))
    (set (<node>-position self) position)
    self))
(define-method set-attr-list <node> (attr-list) ;; identifier-list
  (set (<node>-attr-list self) attr-list)
  self)
(define-method print <node> ()
  (printf "Node output: " <node>))



;; Identifier implemented in CC as extensible array => array-append in boot.l
;; https://lisp-univ-etc.blogspot.com/2019/08/programming-algorithms-arrays.html?m=1
;; Inherits from CCBasic.List
(define-structure <identifier-list> ())
(define-method add <identifier-list> (x) ;; object
    (if (= type <identifier>)
	(array-append (self x))))
(define-method get-identifier <identifier-list> (index) ;; long
  (return self (index))

;; -1 if not present
(define-method index-of <identifier-list> (identifier) ;; object
  (return array-find (self identifier))
  (printf "redundent"))
  
(define-method contains <identifier-list> (identifier) ;; object
  (return array-contains (self ifentifier))

(define-method copy <identifier-list> ()
  (return dup-array (self))

(define-method print <identifier-list> ()
  (print (self))

;; Identifier or QualifiedIdentifier, inherits from node so we add in the additional param
(define-structure <identifier> (node name target)) ;; string node
(define function new-identifier (position id) ;; long symbol/handle/string
  ((let ((self (new <identifier>)))
      (set (<identifier>-node self) new-node (position))
      (set (<identifier>-name self) id)
      self))
(define-method set-target <identifier> (x) ;; node
  (set (<identifier-target self) x)
  self)

(define-method equal <identifier> (x) ;; identifier
  (return id.name = x.name))
(define-method equaltext-identifier <identifier> (
  (return 
(define-method copy <identifier> ()
  (return dup-array (self))
(define-method print <identifier> ()
  (print (self))




(define-form define-binary (op name)
  `(define-function ,(concat-symbol 'subr_ (string->symbol name)) (args ctx)
     (arity2 ,name args)
     (let ((lhs (get_head args))
	   (rhs (get_head (get_tail args))))
       (if (and (is_long lhs) (is_long rhs))
	   (new-<long> (,op (get_long lhs) (get_long rhs)))
	 (printf "%p %p\n" lhs rhs)
	 (k_error "non-numeric argument: (",name" "lhs" "rhs")")))))

(define-binary &  "bitand")
(define-binary |  "bitor")
(define-binary ^  "bitxor")
(define-binary +  "add")
(define-binary *  "mul")
(define-binary /  "div")
(define-binary << "shl")
(define-binary >> "shr")

(define-form define-relation (op name)
  `(define-function ,(concat-symbol 'subr_ (string->symbol name)) (args ctx)
     (arity2 ,name args)
     (let ((lhs (get_head args))
	   (rhs (get_head (get_tail args))))
       (if (and (is_long lhs) (is_long rhs))
	   (and (,op (get_long lhs) (get_long rhs)) s_t)
	 (k_error "non-numeric argument: (",name" "lhs" "rhs")")))))

(define-relation <  "lt")
(define-relation <= "le")
(define-relation >= "ge")
(define-relation >  "gt")

(define-function subr_eq (args ctx)
  (arity2 "=" args)
  (let* ((lhs  (get_head args))
	 (rhs  (get_head (get_tail args)))
	 (type (get-type lhs)))
    (cond
      ((= type <long>)		(and (is_long rhs) (= (get_long lhs) (get_long rhs)) s_t))
      ((= type <string>)	(and (is <string> rhs) (not (strcmp (get <string> _bits lhs) (get <string> _bits rhs))) s_t))
      (else			(and (= lhs rhs) s_t)))))

(define-function subr_ne (args ctx)
  (arity2 "!=" args)
  (let* ((lhs  (get_head args))
	 (rhs  (get_head (get_tail args)))
	 (type (get-type lhs)))
    (cond
      ((= type <long>)		(and (is_long rhs) (!= (get_long lhs) (get_long rhs)) s_t))
      ((= type <string>)	(and (is <string> rhs) (strcmp (get <string> _bits lhs) (get <string> _bits rhs))) s_t)
      (else			(and (!= lhs rhs) s_t)))))

(define-function subr_abort (args ctx)
  (abort))

(define-function subr_exit (args ctx)
  (let ((status (and (is_long (k_car args)) (get_long (k_car args)))))
    (exit status)))

(define-function subr_open (args ctx)
  (let ((arg (k_car args)))
    (or (is <string> arg) (fatal "non-string argument in open"))
    (let ((stream (fopen (get <string> _bits arg) "rb")))
      (and stream (new-<long> stream)))))

(define-function subr_close (args ctx)
  (let ((arg (k_car args)))
    (or (is <long> arg) (fatal "non-integer argument in close"))
    (fclose (get_long arg))
    arg))

(define-function subr_getc (args ctx)
  (let ((arg (k_car args)))
    (or arg (set arg (get <variable> value input)))
    (or (is_long arg) (fatal "non-integer stream id in getc"))
    (let ((c (getc (get_long arg))))
      (and (>= c 0)
	   (new-<long> c)))))

(define-function subr_putc (args ctx)
  (let ((arg (k_car args))
	(obj (k_cadr args)))
    (or arg (set arg (get <variable> value input)))
    (or (is_long arg) (fatal "non-integer stream id in putc"))
    (or (is_long obj) (fatal "non-integer character in putc"))
    (new-<long> (putc (get_long arg)))))

(define-function subr_format (args ctx)
  (arity2 "format" args)
  (let ((ofmt (k_car args))
	(oarg (k_cadr args)))
    (or (is <string> ofmt) (fatal "non-string format"))
    (let ((fmt (get <string> _bits ofmt))
	  (typ (get-type oarg))
	  (arg ()))
      (cond
	((= typ <undefined>))
	((= typ <long>)		(set arg (get_long oarg)))
	((= typ <string>)	(set arg (get <string> _bits oarg)))
	((= typ <symbol>)	(set arg (get <symbol> _bits oarg)))
	(else			(set arg oarg)))
      (let ((size 100) (p) (np))
	(or (set p (malloc size) (return ())))
	(while 1
	  (let ((n (snprintf p size fmt arg)))
	    (and (<= 0 n) (< n size)
		 (let ((ans (new-<string> p)))
		   (free p)
		   (return ans)))
	    (set size (* size 2)))
	  (or (set np (realloc p size))
	      (let ()
		(free p)
		(return "out of memory")))
	  (set p np))))))

(define-function subr_dump (args ctx)
  (while (is <pair> args)
    (k_dump (get_head args))
    (set args (get_tail args))))

(define-function subr_print (args ctx)
  (while (is <pair> args)
    (k_print (get_head args))
    (set args (get_tail args))))

(define-function subr_warn (args ctx)
  (while (is <pair> args)
    (let* ((arg  (get_head args))
	   (type (get-type arg)))
      (cond
	((= type <string>) (fprintf stderr "%s" (get <string> _bits arg)))
	((= type <symbol>) (fprintf stderr "%s" (get <symbol> _bits arg)))))
    (set args (get_tail args))))

(define-function subr_apply (args ctx)
  (k_apply (k_car args) (k_cadr args) ctx))

(define-function subr_eval (args ctx)
  (let ((x (k_car args))
	(e (or (k_cadr args) (new-<env> (get <variable> value globals) 1 0))))
    (gc-protect (x e)
      (let ((c (new-base-<context> () () e)))
        (gc-protect (c)
	  (set x (k_expand x e))
	  (set x (k_encode x e))
	  (k_eval x c))))))

(define-function subr_encode (args ctx)
  (k_encode (k_car args)
	    (or (k_cadr args)
		(get <context> env ctx))))

(define-function subr_expand (args ctx)
  (k_expand (k_car args)
	    (or (k_cadr args)
		(get <context> env ctx))))

(define-function subr_cons	(args ctx)	(new-<pair> (k_car args) (k_cadr args)))
(define-function subr_string	(args ctx)	(_new-<string> (and (is_long (k_car args)) (get_long (get_head args)))))
(define-function subr_array	(args ctx)	(new-<array> (and (is_long (k_car args)) (get_long (get_head args)))))
(define-function subr_form	(args ctx)	(new-<form> (k_car args) (k_cadr args)))

(define-function subr_allocate (args ctx)
  (arity2 "allocate" args)
  (let ((type (get_head args))
	(size (get_head (get_tail args))))
    (and (is_long type) (is_long size)
	 (new-oops (get_long type) (* (get_long size) 4)))))

(define-function subr_type_of	(args ctx)	(and args (new-<long> (get-type (k_car args)))))
(define-function subr_stringP	(args ctx)	(and (is <string> (k_car args)) s_t))
(define-function subr_symbolP	(args ctx)	(and (is <symbol> (k_car args)) s_t))
(define-function subr_pairP	(args ctx)	(and (is <pair> (k_car args)) s_t))
(define-function subr_arrayP	(args ctx)	(and (is <array> (k_car args)) s_t))
(define-function subr_car	(args ctx)	(k_car (k_car args)))
(define-function subr_cdr	(args ctx)	(k_cdr (k_car args)))

(define-function subr_set_car (args ctx)
  (let ((arg (k_car args)))
    (and (is <pair> arg)
	 (put <pair> head arg (k_cadr args)))))

(define-function subr_set_cdr (args ctx)
  (let ((arg (k_car args)))
    (and (is <pair> arg)
	 (put <pair> tail arg (k_cadr args)))))

(define-function subr_oop_at (args ctx)
  (arity2 "oop-at" args)
  (let ((obj (get_head args))
	(arg (get_head (get_tail args))))
    (and obj (not (is_long obj))
	 (is_long arg)
	 (oop-at obj (get_long arg)))))

(define-function subr_set_oop_at (args ctx)
  (arity3 "set-oop-at" args)
  (let ((obj (get_head args))
	(arg (get_head (get_tail args)))
	(val (get_head (get_tail (get_tail args)))))
    (and obj (not (is_long obj))
	 (is_long arg)
	 (set-oop-at obj (get_long arg) val))
    val))

(define-function subr_array_length (args ctx)
  (new-<long> (k_array_length (k_car args))))

(define-function subr_array_at (args ctx)
  (arity2 "array-at" args)
  (let ((arr (get_head args))
	(arg (get_head (get_tail args))))
    (and (is_long arg)
	 (k_array_at arr (get_long arg)))))

(define-function subr_set_array_at (args ctx)
  (arity3 "set-array-at" args)
  (let ((arr (get_head args))
	(arg (get_head (get_tail args)))
	(val (get_head (get_tail (get_tail args)))))
    (and (is_long arg)
	 (k_set_array_at arr (get_long arg) val))))

(define-function subr_string_length (args ctx)
  (let ((arg (k_car args)))
    (and (is <string> arg)
	 (get <string> size arg))))

(define-function subr_string_at (args ctx)
  (arity2 "string-at" args)
  (let ((arr (get_head args))
	(arg (get_head (get_tail args))))
    (and (is_long arg)
	 (let ((idx (get_long arg)))
	   (and (<= 0 idx) (< idx (k_string_length arr))
		(new-<long> (string-at (get <string> _bits arr) idx)))))))

(define-function subr_set_string_at (args ctx)
  (arity3 "set-string-at" args)
  (let ((arr (get_head args))
	(arg (get_head (get_tail args)))
	(val (get_head (get_tail (get_tail args)))))
    (and (is_long arg) (is_long val)
	 (let ((idx (get_long arg)))
	   (and (<= 0 idx) (< idx (k_string_length arr))
		(let ()
		  (set-string-at (get <string> _bits arr) idx (get_long val))
		  val))))))

(define-function subr_string_symbol (args ctx)
  (let ((arg (k_car args)))
    (if (is <symbol> arg)
	arg
      (and (is <string> arg)
	   (intern (get <string> _bits arg))))))

(define-function subr_symbol_string (args ctx)
  (let ((arg (k_car args)))
    (if (is <string> arg)
	arg
      (and (is <symbol> arg)
	   (new-<string> (get <symbol> _bits arg))))))

(define-function subr_long_string (args ctx)
  (let ((arg (k_car args)))
    (if (is <string> arg)
	arg
      (and (is_long arg)
	   (let ((buf (malloc 32)))
	     (sprintf buf "%ld" (get_long arg))
	     (let ((result (new-<string> buf)))
	       (free buf)
	       result))))))

(define-function subr_verbose (args ctx)
  (let ((arg (k_car args)))
    (if (is_long arg)
	(set opt_verbose (get_long arg))
      (new-<long> opt_verbose))))

(define-function subr_optimised (args ctx)
  (let ((arg (k_car args)))
    (if (is_long arg)
	(set opt_optimised (get_long arg))
      (new-<long> opt_optimised))))

(define-function subr_read (args ctx)
  (if (= () args)
      (let ((obj (k_read stdin)))
	(and (= DONE obj) (set obj ()))
	obj)
    (let ((arg (k_car args)))
      (or (is <string> arg) (fatal1 "read: non-String argument: " arg))
      (let* ((path   (get <string> _bits arg))
	     (stream (fopen path "r")))
	(if stream
	    (let* ((head (new-<pair> () ()))
		   (tail head)
		   (obj  ()))
	      (gc-protect (head obj)
	        (while (!= DONE (set obj (k_read stream)))
		  (set tail (set_tail tail (new-<pair> obj ())))))
	      (fclose stream)
	      (get_tail head))
	  ())))))

;;; ----------------------------------------------------------------

(define-function repl_stream (stream)
  (put <variable> value input (new-<long> stream))
  (let ((res ()))
    (gc-protect (res)
      (or (= stdin stream) (fscanf stream "#!%*[^\012\015]"))
      (while (let ()
  	     (and (= stdin stream) (fprintf stdout ".") (fflush stdout))
  	     (!= DONE (set res (k_read stream))))
        (let ((env (new-<env> (get <variable> value globals) 1 0)))
          (gc-protect (env)
  	  (and (> opt_verbose 0) (printf ";;; ") (k_dumpln res))
  	  (set res (k_expand res env))					(and (> opt_verbose 2) (printf "expd--> ") (k_dumpln res))
  	  (set res (k_encode res env))					(and (> opt_verbose 2) (printf "encd--> ") (k_dumpln res))
  	  (let ((ctx (new-base-<context> () () env)))
  	    (gc-protect (ctx)
  	      (set res (k_eval res ctx))				(and (> opt_verbose 1) (printf "eval--> ") (k_dumpln res))
  	      (if (= stdin stream)
  		  (k_dumpln res)
  		(and (> opt_verbose 0) (printf ";;; => ") (k_dumpln res))))))))
      (and (= stdin stream)
	   (printf "\nmorituri te salutant\n")))
    res))

(define-function define-subr (name imp)
  (let ((tmp (new-<subr> imp name)))
    (gc-protect (tmp)
      (k_env_define (get <variable> value globals) (intern name) tmp))))

(define-function define-fsubr (name imp)
  (let ((tmp (new-<subr> imp name)))
    (gc-protect (tmp)
      (set tmp (new-<fixed> tmp))
      (k_env_define (get <variable> value globals) (intern name) tmp))))

(define-function main (argc argv)
  (set stdin  (fdopen 0 "r"))
  (set stdout (fdopen 1 "a"))
  (set stderr (fdopen 2 "a"))

  (gc_initialise)							(gcdebug (set gc_frequency 1))

  (set symbols (new-<array> 0))						(gc_push_root (address-of symbols))

  (set s_t			(intern "t"))
  (set s_dot			(intern "."))
  (set s_set			(intern "set"))
  (set s_define			(intern "define"))
  (set s_lambda			(intern "lambda"))
  (set s_let			(intern "let"))
  (set s_quote			(intern "quote"))
  (set s_quasiquote		(intern "quasiquote"))
  (set s_unquote		(intern "unquote"))
  (set s_unquote_splicing	(intern "unquote-splicing"))

  (gc_push_root (address-of globals))

  (set globals (new-<env> () 0 0))
  (set globals (k_env_define globals (intern "*globals*") globals))

  (set input	   (k_env_define (get <variable> value globals) (intern "*input*"      ) ()))	(gc_push_root (address-of input      ))
  (set expanders   (k_env_define (get <variable> value globals) (intern "*expanders*"  ) ()))	(gc_push_root (address-of expanders  ))
  (set encoders    (k_env_define (get <variable> value globals) (intern "*encoders*"   ) ()))	(gc_push_root (address-of encoders   ))
  (set evaluators  (k_env_define (get <variable> value globals) (intern "*evaluators*" ) ()))	(gc_push_root (address-of evaluators ))
  (set applicators (k_env_define (get <variable> value globals) (intern "*applicators*") ()))	(gc_push_root (address-of applicators))

  (define-fsubr "define"		subr_define)
  (define-fsubr "lambda"		subr_lambda)
  (define-fsubr "let"			subr_let)
  (define-fsubr "set"			subr_set)
  (define-fsubr "while"			subr_while)
  (define-fsubr "if"			subr_if)
  (define-fsubr "or"			subr_or)
  (define-fsubr "and"			subr_and)
  (define-fsubr "quote"			subr_quote)
  (define-subr  "defined?"		subr_definedP)
  (define-subr  "not"			subr_not)
  (define-subr  "&"			subr_bitand)
  (define-subr  "|"			subr_bitor)
  (define-subr  "^"			subr_bitxor)
  (define-subr  "+"			subr_add)
  (define-subr  "-"			subr_sub)
  (define-subr  "*"			subr_mul)
  (define-subr  "/"			subr_div)
  (define-subr  "<<"			subr_shl)
  (define-subr  ">>"			subr_shr)
  (define-subr  "<"			subr_lt)
  (define-subr  "<="			subr_le)
  (define-subr  "!="			subr_ne)
  (define-subr  "="			subr_eq)
  (define-subr  ">="			subr_ge)
  (define-subr  ">"			subr_gt)
  (define-subr  "abort"			subr_abort)
  (define-subr  "exit"			subr_exit)
  (define-subr  "format"		subr_format)
  (define-subr  "dump"			subr_dump)
  (define-subr  "print"			subr_print)
  (define-subr  "warn"			subr_warn)
  (define-subr  "apply"			subr_apply)
  (define-subr  "eval"			subr_eval)
  (define-subr  "encode"		subr_encode)
  (define-subr  "expand"		subr_expand)
  (define-subr  "cons"			subr_cons)
  (define-subr  "string"		subr_string)
  (define-subr  "array"			subr_array)
  (define-subr  "form"			subr_form)
  (define-subr  "open"			subr_open)
  (define-subr  "close"			subr_close)
  (define-subr  "getc"			subr_getc)
  (define-subr  "putc"			subr_putc)
  (define-subr  "allocate"		subr_allocate)
  (define-subr  "type-of"		subr_type_of)
  (define-subr  "string?"		subr_stringP)
  (define-subr  "symbol?"		subr_symbolP)
  (define-subr  "pair?"			subr_pairP)
  (define-subr  "array?"		subr_arrayP)
  (define-subr  "car"			subr_car)
  (define-subr  "cdr"			subr_cdr)
  (define-subr  "set-car"		subr_set_car)
  (define-subr  "set-cdr"		subr_set_cdr)
  (define-subr  "oop-at"		subr_oop_at)
  (define-subr  "set-oop-at"		subr_set_oop_at)
  (define-subr  "array-length"		subr_array_length)
  (define-subr  "array-at"		subr_array_at)
  (define-subr  "set-array-at"		subr_set_array_at)
  (define-subr  "string-length"		subr_string_length)
  (define-subr  "string-at"		subr_string_at)
  (define-subr  "set-string-at"		subr_set_string_at)
  (define-subr  "string->symbol"	subr_string_symbol)
  (define-subr  "symbol->string"	subr_symbol_string)
  (define-subr  "long->string"		subr_long_string)
  (define-subr  "verbose"		subr_verbose)
  (define-subr  "optimised"		subr_optimised)
  (define-subr  "read"			subr_read)

  (let ((tmp ()))
    (gc-protect (tmp)
      (while (< 0 (set argc (- argc 1)))
	(set tmp (new-<pair> () tmp))
	(set_head tmp (new-<string> (oop-at argv argc))))
      (set arguments (k_env_define (get <variable> value globals) (intern "*arguments*") tmp))))

  (set f_set	(k_env_lookup (get <variable> value globals) s_set   ))		(gc_push_root (address-of f_set   ))
  (set f_quote	(k_env_lookup (get <variable> value globals) s_quote ))		(gc_push_root (address-of f_quote ))
  (set f_lambda	(k_env_lookup (get <variable> value globals) s_lambda))		(gc_push_root (address-of f_lambda))
  (set f_let	(k_env_lookup (get <variable> value globals) s_let   ))		(gc_push_root (address-of f_let	  ))
  (set f_define	(k_env_lookup (get <variable> value globals) s_define))		(gc_push_root (address-of f_define))

  (set trace_stack (new-<array> 32))				(gc_push_root (address-of trace_stack))

  (k_env_define (get <variable> value globals) (intern "*backtrace*") ())

  (while (is <pair> (get <variable> value arguments))
    (let* ((argl (get <variable> value arguments))
	   (args (get_head argl))
	   (arg  (get <string> _bits args)))
      (gc-protect (args)
        (put <variable> value arguments (get_tail argl))
	(cond
	  ((not (strcmp arg "-v"))	(set opt_verbose   (+ 1 opt_verbose)))
	  ((not (strcmp arg "-O"))	(set opt_optimised (+ 1 opt_optimised)))
	  ((not (strcmp arg "-"))		(repl_stream stdin))
	  (else				(let ((stream (fopen arg "r")))
					  (or stream (fatal1 "no such file: %s" arg))
					  (repl_stream stream)
					  (fclose stream)))))))

  (and (> opt_verbose 0)
       (let ()
	 (gc_gcollect)
	 (printf "GC: %d objects in %d bytes, %d free\n" gc_objects_live gc_bytes_used gc_bytes_free)))

  (fprintf stderr "%d objects in %d bytes, %d free\n" gc_objects_live gc_bytes_used gc_bytes_free)

  0)

(compile-end)

#+end_src 

*** boot.l

We inject utilities just to illustrate - modularise code later

#+begin_src lisp :noweb yes :mkdirp yes :tangle src/boot.l
(define unit-testing? '(t))

(define list (lambda args args))

(define %print print)
(define %dump  dump)

(define error)

(define %error
  (lambda args
    (set error abort)
    (%print "\nERROR: ")
    (apply %print args)
    (%print "\n")
    (abort)))

;; trampoline the errors down the stack?
(set error
  (lambda args
    (set error %error)
    (%print "\n[31;1merror: ")
    (apply print args)
    (%print "[m\n")
    (abort)))

(define caar (lambda (x) (car (car x))))
(define cadr (lambda (x) (car (cdr x))))
(define cdar (lambda (x) (cdr (car x))))
(define cddr (lambda (x) (cdr (cdr x))))
(define cadar (lambda (x) (car (cdr (car x)))))
(define caadr (lambda (x) (car (car (cdr x)))))
(define cdadr (lambda (x) (cdr (car (cdr x)))))
(define caddr (lambda (x) (car (cdr (cdr x)))))
(define cdddr (lambda (x) (cdr (cdr (cdr x)))))
(define caddar (lambda (x) (car (cdr (cdr (car x))))))
(define caaddr (lambda (x) (car (car (cdr (cdr x))))))
(define cadddr (lambda (x) (car (cdr (cdr (cdr x))))))
(define cddddr (lambda (x) (cdr (cdr (cdr (cdr x))))))

(define memq
  (lambda (object list)
    (let ((result ()))
      (while (pair? list)
	(if (= object (car list))
	    (let ()
	      (set result list)
	      (set list ()))
	  (set list (cdr list))))
      result)))

(define assq
  (lambda (object list)
    (let ((result ()))
      (while (pair? list)
	(if (= object (caar list))
	    (let ()
	      (set result (car list))
	      (set list ())))
	(set list (cdr list)))
      result)))

(define concat-list
  (lambda (x y)
    (if (pair? x)
	(cons (car x) (concat-list (cdr x) y))
      y)))

(define concat-string
  (lambda (x y)
    (let ((a (string-length x))
	  (b (string-length y)))
      (let ((s (string (+ a b)))
	    (i 0)
	    (j 0))
	(while (< i a)
	  (set-string-at s j (string-at x i))
	  (set i (+ i 1))
	  (set j (+ j 1)))
	(set i 0)
	(while (< i b)
	  (set-string-at s j (string-at y i))
	  (set i (+ i 1))
	  (set j (+ j 1)))
	s))))

(define concat-strings
  (lambda args
    (let ((result (car args)))
      (while (string? (car (set args (cdr args))))
	(set result (concat-string result (car args))))
      result)))

(define concat-symbol
  (lambda (x y)
    (string->symbol (concat-string (symbol->string x) (symbol->string y)))))

(define quasiquote
  (form
    (let ((qq-list) (qq-element) (qq-object))
      (set qq-list (lambda (l)
		     (if (pair? l)
			 (let ((obj (car l)))
			   (if (and (pair? obj) (= (car obj) 'unquote-splicing))
			       (if (cdr l)
				   (list 'concat-list (cadr obj) (qq-list (cdr l)))
				 (cadr obj))
			     (list 'cons (qq-object obj) (qq-list (cdr l)))))
		       (list 'quote l))))
      (set qq-element (lambda (l)
			(let ((head (car l)))
			  (if (= head 'unquote)
			      (cadr l)
			    (qq-list l)))))
      (set qq-object (lambda (object)
		       (if (pair? object)
			   (qq-element object)
			 (list 'quote object))))
      (lambda (env expr)
	(qq-object expr)))))

; Core language? -------

; Special / built-in forms
;
; As long as you have a way to hook into the eval / applicative nature
; of things you can get away with quite a bit: http://www.vpri.org/pdf/tr2011002_oecm.pdf
;
; In other words, you can anotate your structures with type constructors
; (e.g. the head of the list is a symbol) and build your reader in
; a way that you can switch on the type constructor rather than hard code
; a set of symbols to match on the imput stream.
;
; `lambda`
;
; `form` - this simply defines a new type of structure that holds on to a `fn`
;          and optionally a body. The reader expander needs to know how to
;          expand the input if the head of the input is as structure of type `form`
;          i.e. the captured `fn` should produce a form given the rest of list as input.


; Defines new reader form into the environment
; auto-capturing the env at the point of definition.
;
; define-form: name, args, body -> ()
; side effects: *env*[name] <- (form (fn (*env*, @args) @body))
; https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace
; *env* are globals with local scope overwrite
; ,@args are spliced in 
; -> gathered output returned as a type else NIL
; note the destructuring operators ` and ,
; note (car . cdr) and see TODO - ARGUMENTS SHOULD NOT BE CONSed


(define define-form (form (lambda (env name args . body)
			    `(define ,name (form (lambda (*env* ,@args) ,@body))))))

(define-form define-function (name args . body)
  `(define ,name (lambda ,args ,@body)))

(define-form define-macro (name args . body)
  `(define-form ,name ,args (cons 'let (cons () (macro-expand (list-zip-assocs ',args (list ,@args)) ',body)))))

(define-function macro-expand (bindings exp)
  (if (pair? exp)
      (cons (macro-expand bindings (car exp))
	    (macro-expand bindings (cdr exp)))
    (if (symbol? exp)
	(let ((a (assq exp bindings)))
	  (if a (cdr a) exp))
      exp)))

(define-form define-constant (name value)
  `(define ,name (form () (lambda args ',value))))


;; list and array module - multimethod?
(define-function list-length (list)
  (if (pair? list)
      (let ((len 1))
	(while (set list (cdr list)) (set len (+ len 1)))
	len)
    0))

(define %list->array
  (lambda (list index)
    (if (pair? list)
	(let ((a (%list->array (cdr list) (+ 1 index))))
	  (set-array-at a index (car list))
	  a)
      (array index))))

(define-function list->array (list)
  (%list->array list 0))

(define-function array-append (arr val)
  (set-array-at arr (array-length arr) val))

(define-function map1 (function list)
  (let ((head (cons)))
    (let ((tail head))
      (while (pair? list)
	(set tail (set (cdr tail) (cons (function (car list)) ())))
	(set list (cdr list))))
    (cdr head)))

(define-function mapN (function lists)
  (and (pair? (car lists))
       (cons (apply function (map1 car lists))
	     (mapN function (map1 cdr lists)))))

(define-function map (function . lists)
  (if (pair? (cdr lists))
      (mapN function lists)
    (map1 function (car lists))))

(define-function reverse-map (function list)
  (and list
       (let ((tail (reverse-map function (cdr list))))
	 (cons (function (car list)) tail))))

(define-function reverse-with-map (function arg list)
  (and list
       (let ((tail (reverse-with-map function arg (cdr list))))
	 (cons (function arg (car list)) tail))))

(define-function reverse-map-with (function list arg)
  (and list
       (let ((tail (reverse-map-with function (cdr list) arg)))
	 (cons (function (car list) arg) tail))))

(define-function map-with (function list a)
  (if (pair? list)
      (let ((head (function (car list) a)))
	(cons head (map-with function (cdr list) a)))))

(define-function with-map (function a list)
  (if (pair? list)
      (let ((head (function a (car list))))
	(cons head (with-map function a (cdr list))))))

(define-function map-with2 (function list a b)
  (if (pair? list)
      (let ((head (function (car list) a b)))
	(cons head (map-with2 function (cdr list) a b)))))

(define-function with2-map (function a b list)
  (if (pair? list)
      (let ((head (function a b (car list))))
	(cons head (with2-map function a b (cdr list))))))

(define-function with-map2 (function a alist blist)
  (if (pair? alist)
      (let ((head (function a (car alist) (car blist))))
	(cons head (with-map2 function a (cdr alist) (cdr blist))))))

(define-function map2-with (function alist blist a)
  (if (pair? alist)
      (let ((head (function (car alist) (car blist) a)))
	(cons head (map2-with function (cdr alist) (cdr blist) a)))))

(define-function map* (function . lists)
  (if (pair? (car lists))
      (let ((head (apply function (map car lists))))
	(cons head (apply map* (cons function (map cdr lists)))))))

(define-function foldr (op value list)
  (if (pair? list)
      (op (car list) (foldr op value (cdr list)))
    value))

;; https://coderedirect.com/questions/198269/defining-setf-expanders-in-common-lisp
;; Also see the TODO expand example and note the define-form comments
(set *expanders*   (array))	(define-form define-expand (type args . body)	`(set-array-at *expanders*   ,type (lambda ,args ,@body)))
(set *encoders*    (array))	(define-form define-encode (type args . body)	`(set-array-at *encoders*    ,type (lambda ,args ,@body)))
(set *evaluators*  (array))	(define-form define-eval   (type args . body)	`(set-array-at *evaluators*  ,type (lambda ,args ,@body)))
(set *applicators* (array))	(define-form define-apply  (type args . body)	`(set-array-at *applicators* ,type (lambda ,args ,@body)))

;;; let*

(define-function %let*getters (vars getter rest)
  (if (pair? vars)
      (cons (list (car vars) (list 'car getter))
	    (%let*getters (cdr vars) (list 'cdr getter) rest))
    (if (symbol? vars)
	(cons (list vars getter) rest)
      rest)))

(define-function %let*unpack (vars val rest)
    (cons (cons '_%let_values_ val)
	  (%let*getters vars '_%let_values_ rest)))

(define-function %let*bindings (bindings)
  (if (pair? bindings)
      (let ((var     (caar bindings))
	    (val     (cdar bindings)))
	(if (pair? var)
	    (%let*unpack var val (%let*bindings (cdr bindings)))
	  (cons (cons var val) (%let*bindings (cdr bindings)))))))

(define-function %let* (bindings body)
  (if (pair? (cdr bindings))
      `(let (,(car bindings)) ,(%let* (cdr bindings) body))
    `(let ,bindings ,@body)))

(define-form let* bindings-body
  (%let* (%let*bindings (car bindings-body)) (cdr bindings-body)))

;;; cond

;; https://riptutorial.com/common-lisp/example/17267/progn eval zero or more forms
(define-function %progn (prog)	(if (cdr prog) (cons 'let (cons '() prog)) (car prog)))

(define-function %cond (clauses)
  (if (pair? clauses)
      (let* ((clause (car clauses))
	     (test   (car clause))
	     (value  (cdr clause)))
	(if (= 'else test)
	    (%progn value)
	  (if (= '=> (car value))
	      `(let ((_ ,test))
		 (if _ (,(%progn (cdr value)) _) ,(%cond (cdr clauses))))
	    `(if ,test ,(%progn value) ,(%cond (cdr clauses))))))))

(define-form cond clauses (%cond clauses))

<<core-main-util>>

;;; type information

(define %type-names	(array 16))
(define %last-type	-1)

(define %allocate-type
  (lambda (name)
    (set %last-type (+ 1 %last-type))
    (set-array-at %type-names %last-type name)
    %last-type))

(define-function name-of-type (type)	(array-at %type-names type))
(define-function type-name-of (obj)	(name-of-type (type-of obj)))

;;; https://stackoverflow.com/questions/23493877/percent-sign-in-defun-and-defstruct
;;; structure

(define %structure-sizes	(array))
(define %structure-fields	(array))
(define %structure-bases	(array))
(define %structure-derivatives	(array))

(define-function sanity-check-structure-fields (name fields)
  (let ((f fields))
    (while (pair? f)
      (and (memq (car f) (cdr f))
	   (error "field '"(car f)"' multiply-defined in structure: "name" "fields))
      (set f (cdr f)))))

(define-function fields-of-type (type)
  (array-at %structure-fields type))

(define-function inherits-from (type base)
  (and type
       (or (= type base)
	   (inherits-from (array-at %structure-bases type) base))))

(define-function %typecheck (type object)
  (or (= type (type-of object))
      (inherits-from (type-of object) type)
      (error "type check failed for field accessor: expected "type" "(array-at %type-names type)" got "(type-of object)" "(array-at %type-names (type-of object))))
  object)

(define %make-accessor) ;; forward

(define-function %accessor (name)	(if (= ?_ (string-at (symbol->string name) 0)) 'long-at 'oop-at))

(define-function %make-safe-accessor (name fields offset)
  (if fields (cons `(define-form ,(concat-symbol name (concat-symbol '- (car fields))) (self)
		      (list ',(%accessor (car fields))
			    (list '%typecheck ',name self)
			    ,offset))
		   (%make-accessor name (cdr fields) (+ 1 offset)))))

(define-function %make-unsafe-accessor (name fields offset)
  (if fields (cons `(define-form ,(concat-symbol name (concat-symbol '- (car fields))) (self)
		      (list ',(%accessor (car fields))
			    self
			    ,offset))
		   (%make-accessor name (cdr fields) (+ 1 offset)))))

(define %make-accessor
  (if (> (optimised) 0)
      %make-unsafe-accessor
    %make-safe-accessor))

(define-function %make-accessors (name fields)
  (%make-accessor name fields 0))

(define-form define-structure (name fields)
  (let ((type (%allocate-type name))
	(size (list-length fields)))
    (sanity-check-structure-fields name fields)
    (set-array-at %structure-sizes  type size)
    (set-array-at %structure-fields type fields)
    `(let ()
       (define ,name ,type)
       ,@(%make-accessors name fields)
       ,type)))

(define-form new (type . inits)
  (let ((i -1))
    `(let* ((_type_ ,type)
	    (_self_ (allocate _type_ (array-at %structure-sizes _type_))))
       ,@(map (lambda (_init_) (list 'set-oop-at '_self_ (set i (+ i 1)) _init_)) inits)
       _self_)))

(define-function %make-make-inits (prefix inits)
  (and inits
       (cons (list 'set (list (concat-symbol prefix (caar inits)) 'self) (cadar inits))
	     (%make-make-inits prefix (cdr inits)))))

(define-form make (type . inits)
  `(let ((self (new ,type)))
     (with-instance-accessors ,type
       ,@(%make-make-inits (concat-symbol type '-) inits)
       self)))

;; See parser.l for example of class def and instantiation
(define-form define-class (name basis fields)
  (let ((base (eval basis)))
    (set fields (concat-list (array-at %structure-fields base) fields))
    (sanity-check-structure-fields name fields)
    (let ((type   (%allocate-type name))
;	  (offset (list-length (array-at %structure-fields base)))
	  (size   (list-length fields)))
      (set-array-at %structure-sizes  type size)
      (set-array-at %structure-fields type fields)
      (set-array-at %structure-bases  type base)
      (let ((derived (or (array-at %structure-derivatives base)
			 (set-array-at %structure-derivatives base (array)))))
	(array-append derived type))
      `(let ()
	 (define ,name ,type)
	 ,@(%make-accessors name fields)
	 ,type))))

;;; https://stackoverflow.com/questions/31870656/what-does-the-underscore-mean-in-elisp
;;; built-in types

(define-structure <undefined>	())
(define-structure <data>	())
(define-structure <long>	(_bits))				(define-function long? (self) (= <long> (type-of self)))
(define-structure <double>	(_bits))				(define-function double? (self) (= <double> (type-of self)))
(define-structure <string>	(size _bits))
(define-structure <symbol>	(_bits))
(define-structure <pair>	(head tail source))
(define-structure <_array>	())
(define-structure <array>	(size _array))
(define-structure <expr>	(name defn ctx profile))		(define-function expr? (obj) (= <expr> (type-of obj)))
(define-structure <form>	(function symbol))
(define-structure <fixed>	(function))
(define-structure <subr>	(_imp _name _profile))
(define-structure <variable>	(name value env index type))		(define-function variable? (obj) (= <variable> (type-of obj)))
(define-structure <env>		(parent level offset bindings stable))
(define-structure <context>	(home env bindings callee pc))

(define-function fixed (fun)
  (let ((self (new <fixed>)))
    (set (<fixed>-function self) fun)
    self))

(define-function variable (name value env index . opt-type)
  (let ((self (new <variable>)))
    (set (<variable>-name  self) name)
    (set (<variable>-value self) value)
    (set (<variable>-env   self) env)
    (set (<variable>-index self) index)
    (set (<variable>-type  self) (car opt-type))
    self))

(define-function environment (parent)
  (let ((self (new <env>)))
    (set (<env>-parent 	 self) parent)
    (set (<env>-level  	 self) (<env>-level  parent))
    (set (<env>-offset 	 self) (<env>-offset parent))
    (set (<env>-bindings self) (array))
    self))

(define-function environment-define (env name value)
  (let* ((bindings (<env>-bindings env))
	 (offset   (<env>-offset   env))
	 (var      (variable name value env offset)))
    (set (<env>-offset env) (+ offset 1))
    (array-append bindings var)))

(define-function environment-find (env name)
  (let* ((bindings (<env>-bindings env))
	 (offset   (<env>-offset   env))
	 (var      ())
	 (idx      0))
    (while (and (not var) (< idx offset))
      (if (= name (<variable>-name (array-at bindings idx)))
	  (set var (array-at bindings idx))
	(set idx (+ idx 1))))
    var))

(define-function global? (var)	(= 0 (<env>-level (<variable>-env var))))

;;; local syntax

(define-function make-with-form (args-body)
  (and args-body `(lambda (*env* ,@(car args-body)) ,@(cdr args-body))))

(define-form with-forms (bindings . body)
  (let ((env (environment *env*)))
    (while bindings
      (let* ((binding (car   bindings))
	     (name    (car   binding))
	     (fun     (cadr  binding))
	     (var     (caddr binding))
	     (exp     (list 'form (make-with-form fun) (make-with-form var))))
	(environment-define env (caar bindings) (eval exp *env*))
	(set bindings (cdr bindings))))
    (cons 'let (cons () (map-with expand body env)))))

;;; field accesors

(define-function make-instance-accessors (name fields i)
  (and (pair? fields)
       (cons `(,(concat-symbol 'self. (car fields)) () ((name) (list 'oop-at 'self ,i)))
	     (make-instance-accessors name (cdr fields) (+ i 1)))))

(define-form with-instance-accessors (type . body)
  `(with-forms ,(make-instance-accessors type (array-at %structure-fields (eval type)) 0)
    (let () ,@body)))

;;; selector
;; eg. do-print has type selectors

(define-structure <selector> (name methods default))

(define-function selector? (obj) (= <selector> (type-of obj)))

(define-function <selector>-inherit (methods type)
  (let ((method ())
	(probe  type))
    (while (and (set probe (array-at %structure-bases probe))
		(not (set method (array-at methods probe)))))
    ;; (and method (set (array-at methods type) method))	;; copy down the method for performance
    method))

(define-apply <selector> (self . arguments)
  (apply (or (array-at (<selector>-methods self) (type-of (car arguments)))
	     (<selector>-inherit (<selector>-methods self) (type-of (car arguments)))
	     (<selector>-default self))
	 arguments))

(define-function selector (name default)
  (let ((self (new <selector>)))
    (set (<selector>-name    self) name)
    (set (<selector>-methods self) (array))
    (set (<selector>-default self) default)
    self))

(define-function <selector>-add-method (self type method)
  (and (expr? method)
       (or (<expr>-name method)
	   (set (<expr>-name method)
		(concat-symbol (array-at %type-names type) (concat-symbol '. (<selector>-name self))))))
  (set-array-at (<selector>-methods self) type method))

(define-form define-selector (name . default)
  (let ((def (defined? name)))
    (if def
	(if (selector? (<variable>-value def))
	    (list 'quote <variable>-value def)
	  (error name" already defined as non-selector: " (<variable>-value def)))
      (let ()
	(or default (set default `(args (error "selector "',name
					       " has no method for "(array-at %type-names (type-of (car args)))
					       ": "(cons (car args) (map name-of-type (map type-of (cdr args))))))))
	`(define ,name (selector ',name (lambda ,@default)))))))

(define-selector add-method)

(<selector>-add-method add-method <selector>
  (lambda (self type args body)
    (<selector>-add-method self type (eval `(lambda ,args (with-instance-accessors ,type ,@body))))))

(define-form define-method (selector type args . body)
  (or (defined? selector) (eval (list 'define-selector selector)))
  `(add-method ,selector ,type ',(cons 'self args) ',body))

;;; print

(define-selector do-print (arg) (%print arg))
(define-selector do-dump  (arg) (do-print arg))

(define print
  (lambda args
    (while (pair? args)
      (do-print (car args))
      (set args (cdr args)))
    (car args)))

(define dump
  (lambda args
    (while (pair? args)
      (do-dump (car args))
      (set args (cdr args)))
    (car args)))

(define println
  (lambda args
    (apply print args)
    (%print "\n")
    (car args)))

(define dumpln
  (lambda args
    (apply dump args)
    (%print "\n")
    (car args)))

(define-method do-dump  <string> ()	(%dump self))
(define-method do-dump  <array> ()	(%dump self))
(define-method do-print <selector> ()	(print "<selector "(<selector>-name self)">"))

(define-method do-print <pair> ()
  (if (= *globals* (cdr self))
      (print "*globals*")
    (let ()
      (print "(")
      (while self
	(if (pair? self)
	    (print (car self))
	  (let ()
	    (print ". ")
	    (print self)))
	(if (set self (cdr self))
	    (print " ")))
      (print ")"))))

(define-method do-dump <pair> ()
  (if (= *globals* (cdr self))
      (print "*globals*")
    (let ()
      (print "(")
      (while self
	(if (pair? self)
	    (dump (car self))
	  (let ()
	    (print ". ")
	    (print self)))
	(if (set self (cdr self))
	    (print " ")))
      (print ")"))))

(define-function dump-until (target arg)
  (let ((found (= target arg)))
    (if (pair? arg)
	(let ()
	  (print "(")
	  (while arg
	    (if (pair? arg)
		(if (dump-until target (car arg))
		    (let ()
		      (if (cdr arg) (print " ..."))
		      (set found 't)
		      (set arg ())))
	      (let ()
		(print ". ")
		(dump-until target arg)))
	    (if (set arg (cdr arg))
		(print " ")))
	  (print ")"))
      (dump arg))
    found))

(if '()
    (set *backtrace*
	 (lambda (stack depth)
	   (println "\n")
	   (let ((posn (array)))
	     (while (>= (set depth (- depth 1)) 0)
	       (let ((here (array-at stack depth)))
		 (print "  " depth "\t")
		 (dump-until posn here)
		 (print "\n")
		 (set posn here))))
	   (exit 1)))
  ;;(println "; backtrace disabled")
  )

;;; multimethod

(define-structure <generic> (name methods default))

(define-function generic (name default)
  (let ((self (new <generic>)))
    (set (<generic>-name    self) name)
    (set (<generic>-methods self) (array))
    (set (<generic>-default self) default)
    self))

(define-method do-print <generic> () (print "<multimethod:" (<generic>-name self) ">"))

(define-form define-generic (name . default)
  (or default (set default `(args (error "no method in "',name" corresponding to: "args))))
  `(define ,name (generic ',name (lambda ,@default))))

; Create nested arrays - 1 per arg type.
; The index is the type value (long)
(define-function %add-multimethod (mm types method)
  (or (<expr>-name method) (set (<expr>-name method) (<generic>-name mm)))
  (if types
      (let ((methods (or (<generic>-methods mm)
			 (set (<generic>-methods mm) (array 32)))))
	(while (cdr types)
	  (let ((type (eval (car types))))
	    (set methods (or (array-at methods type)
			     (set (array-at methods type) (array 32)))))
	  (set types (cdr types)))
	(set (array-at methods (eval (car types))) method))

    ; else - no types, overwrite all dispatchers with a single method
    ; XXX error out here?
    (set (<generic>-methods mm) method)))

; Define a new multi-method impl
; typed-args is a list of pairs ((type, name)...)
(define-form define-multimethod (method typed-args . body)
  (let ((args  (map cadr typed-args))
	(types (map car  typed-args)))
    (or (defined? method) (eval (list 'define-generic method)))
    `(%add-multimethod ,method (list ,@types) (lambda ,args ,@body))))

; Make the <generic> structure an applicative
(define-apply <generic> (self . arguments)
  (let ((method (<generic>-methods self))
	(arg     arguments))
    (while arg
      (set method (array-at method (type-of (car arg))))
      (set arg (cdr arg)))
    (if (and method (not (array? method)))
	(apply method arguments)
      (let ((default (<generic>-default self)))
	(if default
	    (apply default arguments)
	  (error "no method in "(<generic>-name self)" corresponding to "arguments))))))

;;; list

(define-form push (list element)
  `(set ,list (cons ,element ,list)))

(define-form pop (list)
  `(let* ((_list_ ,list) (_head_ (car _list_)))
     (set ,list (cdr _list_))
     _head_))

(define-function member? (key list)
  (while (and (pair? list) (!= key (car list)))
    (set list (cdr list)))
  (car list))

(define-function list-reverse! (head)
  (let ((curr head)
	(prev ())
	(next ()))
    (while curr
      (set next (cdr curr))
      (set-cdr curr prev)
      (set prev curr)
      (set curr next))
    prev))

(define-function list-zip lists		(apply map list lists))

(define-function list-zip-assocs (a b)
  (if (and (pair? a) (pair? b))
      (cons (cons (car a) (car b)) (list-zip-assocs (cdr a) (cdr b)))
    (or a b)))

;;; iteration

(define-form for (var-init-limit-step . body)
  (let ((var   	   (car    var-init-limit-step)	   )
	(init  	   (cadr   var-init-limit-step)	   )
	(limit 	   (caddr  var-init-limit-step)	   )
	(step  (or (cadddr var-init-limit-step) 1)))
    `(let ((,var ,init) (_limit_ ,limit))
       (while (< ,var _limit_)
	 ,@body
	 (set ,var (+ ,var ,step))))))

(define-form list-do (var list . body)
  `(let ((_list_ ,list))
     (while _list_
       (let* ((,var (car _list_))) ,@body)	;; let* allows (list-do (vars...) list-of-lists)
       (set _list_ (cdr _list_)))))

(define-form alist-do (var alist . body)
  `(let ((_list_ ,alist))
     (while _list_
       (let*  ((,var (cdar _list_))) ,@body)
       (set _list_ (cdr _list_)))))

(define-function %generic-do (get len var col body)
  `(let* ((_col_ ,col)
	  (_idx_ 0)
	  (_end_ (,len _col_)))
     (while (< _idx_ _end_)
       (let* ((,var (,get _col_ _idx_))) ,@body)
       (set _idx_ (+ _idx_ 1)))))

(define-form array-do (var arr . body)	(%generic-do array-at array-length var arr body))

(define-form string-do (var str . body)	(%generic-do string-at string-length var str body))

(define-method for-each <pair>   (function)	(list-do   _elt_ self (function _elt_)))
(define-method for-each <array>  (function)	(array-do  _elt_ self (function _elt_)))
(define-method for-each <string> (function)	(string-do _elt_ self (function _elt_)))

(define-function for-each-with (collection function value)
  (for-each collection (lambda (x) (function x value))))

(define-form incr (lval . options)	`(set ,lval (+ ,lval ,(or (car options) 1))))
(define-form decr (lval . options)	`(set ,lval (- ,lval ,(or (car options) 1))))

(define-form until (condition . body)
  `(while (not ,condition) ,@body))

(define-form list-detect (name list expr)
  `(let ((_ ())
	 (__ ,list))
     (while (and __ (not _))
       (let ((,name (car __)))
	 (and ,expr (set _ ,name))
	 (set __ (cdr __))))
     _))

(define-form array-detect (name arr expr)
  `(let* ((_ ())
	  (_a ,arr)
	  (_l (array-length _a)))
     (for (_i 0 _l)
       (let ((,name (array-at _a _i)))
	 (and ,expr (let () (set _ ,name) (set _i _l)))))
     _))

(define-form when (test . body)		`(and ,test (let () ,@body)))
(define-form unless (test . body)	`(or  ,test (let () ,@body)))

(define-function %loop-inits (bindings)
  (and bindings
       (cons (list (caar bindings) (cadar bindings))
	     (%loop-inits (cdr bindings)))))

(define-function %loop-steps (bindings)
  (and bindings
       (cons (list 'set (caar bindings) (caddar bindings))
	     (%loop-steps (cdr bindings)))))

(define-form loop (bindings test . body)
  `(let ,(%loop-inits bindings)
     (while ,test
       ,@body
       ,@(%loop-steps bindings))))

;;; conversion

(define-function string->number-base (str radix)
  (let ((n 0)
	(i 0)
	(l (string-length str))
	(s 1))
    (while (and (< i l) (= ?- (string-at str i)))
      (set s (- s))
      (set i (+ i 1)))
    (while (< i l)
      (let* ((c (string-at str i))
	     (d (cond
		  ((and (<= ?0 c) (<= c ?9))	      (- c ?0) )
		  ((and (<= ?A c) (<= c ?Z))	(+ 10 (- c ?A)))
		  ((and (<= ?a c) (<= c ?z))	(+ 10 (- c ?a)))
		  (else				      radix    ))))
	(if (< d radix)
	    (let ()
	      (set n (+ (* radix n) d))
	      (set i (+ i 1)))
	  (set l i))))
    (* s n)))

(define-function string->number (str)
  (string->number-base str 10))

(define-function array->string (arr)
  (let* ((ind 0)
	 (lim (array-length arr))
	 (str (string lim)))
    (while (< ind lim)
      (set-string-at str ind (array-at arr ind))
      (set ind (+ 1 ind)))
    str))

(define-function array->list (arr)
  (let* ((ind (array-length arr))
	 (lst ()))
    (while (<= 0 (set ind (- ind 1)))
      (set lst (cons (array-at arr ind) lst)))
    lst))

(define-function list->string (list)
  (let* ((len (list-length list))
	 (str (string len))
	 (idx 0))
    (while (< idx len)
      (set-string-at str idx (car list))
      (set idx (+ idx 1))
      (set list (cdr list)))
    str))

(define-function character->string (c)
  (let ((s (string 1)))
    (set-string-at s 0 c) s))

(define-function array-append-all (a s)
  (string-do e s (array-append a e))
  s)

;;; sorting and searching

(define-function %partition (items at set-at compare left pivot right)
  (let ((index left)
	(value (at items pivot)))
    (set-at items pivot (at items right))
    (set-at items right value)
    (for (i left right)
      (and (compare (at items i) value)
	   (let ((item (at items i)))
	     (set-at items i (at items index))
	     (set-at items index item)
	     (set index (+ index 1)))))
    (set value (at items index))
    (set-at items index (at items right))
    (set-at items right value)
    index))

(define-function %sort (items at set-at compare left right)
  (and (< left right)
       (let* ((pivot (/ (+ left right) 2))
	      (index (%partition items at set-at compare left pivot right)))
	 (%sort items at set-at compare left (- index 1))
	 (%sort items at set-at compare (+ index 1) right))))

(define-function array-sort (items . options)
  (%sort items array-at set-array-at (or (car options) <) 0 (- (array-length items) 1))
  items)

(define-function string-sort (items . options)
  (%sort items string-at set-string-at (or (car options) <) 0 (- (string-length items) 1))
  items)

(define-function %search (items length at obj compare)
  (let ((lo 0)
	(hi (- (length items) 1))
	(ix ()))
    (while (<= lo hi)
      (let* ((m (/ (+ lo hi) 2))
	     (s (at items m))
	     (c (compare obj s)))
	(cond
	  ((< c 0)	(set hi (- m 1)))
	  ((> c 0)	(set lo (+ m 1)))
	  (else		(let () (set ix m) (set lo (+ hi 1)))))))
    ix))

(define-function array-search  (arr obj . options)	(%search arr array-length  array-at  obj (or (car options) -)))
(define-function string-search (str obj . options)	(%search str string-length string-at obj (or (car options) -)))

(define-function max (a . rest)	(list-do b rest (set a (if (> b a) b a))) a)
(define-function min (a . rest)	(list-do b rest (set a (if (< b a) b a))) a)
(define-function sum (a . rest)	(list-do b rest (incr a b)) a)

;;; structural equality

(define equal ()) ;; forward

(define-function equal-lists (a b)
  (and (equal (car a) (car b))
       (equal (cdr a) (cdr b))))

(set equal (lambda (a b)
  (or (= a b)
      (and (pair? a)
	   (pair? b)
	   (equal-lists a b)))))

;;; unit testing

(define-form unit-fail (expr)
  `(error "UNIT FAIL "unit-name": "',expr))

(define-form unit-assert (expr)
  `(or ,expr (unit-fail ,expr)))

(define-form unit-test (name . body)
  (and unit-testing?
       `(let ((unit-name ,name))
	  ,@body)))

;;; namespace
;; https://coderedirect.com/questions/198269/defining-setf-expanders-in-common-lisp
;; class namespace  with type, condition and struct namespace
;; function namspace  with macro-function and generic-function namespace
;; value namespace  with symbol-macro namespace
;; Also see TODO reader/expander example - not implemented yet
;; http://picolisp.com/wiki/-A341.html more info on the namespace intent in maru
;; http://tinyscheme.sourceforge.net/oo.txt objects and classes are environments?
;; maru doesn't agree, prob as the compiler requires classes
;; https://github.com/radiganm/shen-modulesys/blob/master/modulesys_howto.md
;; https://github.com/tizoc/shen-scheme use shen+ukanren+maude in stdlib
;; as shen has subtypes https://shenlanguage.org/OSM/Subtypes.html
;; Blaeser_ETH_Diss_2007.pdf A component encapsulates state (data values and components),
;; as well as behaviour (interactions and functionality). Component Templates.


(define *global* *globals*)

(define-form define-namespace (name parent)	`(define ,name (environment ,parent)))

(define-form namespace (name)			`(set *globals* ,name))

;;; command line

(define *load-path*)

(and (= "-L" (car *arguments*))
     (let ()
       (pop *arguments*)
       (set *load-path* (pop *arguments*))))

(define-form next-argument () '(pop *arguments*))

;;; load/save

(define-function pval (expr)
  (and (> (verbose) 0) (println expr))
  (let ((result (eval expr)))
    (and (> (verbose) 1) (println "=> "result))
    result))

(define-function find-and-read (name)
  (or (and *load-path* (read (concat-string *load-path* name)))
      (read name)))

(define-function load (name)
  (let ((exps (find-and-read name)))
    (or exps (error "file not found or empty: "name))
    (list-do expr exps (pval expr))))

(define *loaded*)

(define-function require (name)
  (or (member? name *loaded*)
      (let ()
	(push *loaded* name)
	(load name))))

(define-method length <string> ()		(string-length self))
(define-method length <array> ()		(array-length self))

(define-method at <string> (index)		(string-at self index))
(define-method at <array> (index)		(array-at self index))

(define-method set-at <string> (index value)	(string-at self index))
(define-method set-at <array> (index value)	(array-at self index))

(define-function contents-to-file-named (string path . options)
  (let ((f (or (open path "w")
	       (error "cannot open for writing: "path)))
	(p (or (car options) putc)))
    (for (i 0 (length string)) (p (at string i) f))
    (close f)))

(define-function contents-of-file-named (path)
  (let ((f (or (open path)
	       (error "cannot open for reading: "path)))
	(s (array))
	(c))
    (while (set c (getc f))
      (array-append s c))
    (close f)
    (array->string s)))
#+end_src

** Utils

Common utilities.

#+name: core-main-util
#+begin_src lisp :tangle no
; Utilities

(define-function concat-list (x y)
                 (if (pair? x)
                   (cons (car x) (concat-list (cdr x) y))
                   y))

(define-function concat-string (x y)
                 (let ((a (string-length x))
                       (b (string-length y)))
                   (let ((s (string (+ a b)))
                         (i 0)
                         (j 0))
                     (while (< i a)
                            (set-string-at s j (string-at x i))
                            (set i (+ i 1))
                            (set j (+ j 1)))
                     (set i 0)
                     (while (< i b)
                            (set-string-at s j (string-at y i))
                            (set i (+ i 1))
                            (set j (+ j 1)))
                     s)))

(define-function concat-strings (. strings)
                 (let ((head (car strings))
                       (rest (or (cdr strings) "")))
                   (if head
                     (concat-string head (apply concat-strings rest))
                     "")))

(define-function concat-symbol (. symbols)
                 (let ((sym-strings (map symbol->string symbols)))
                   (string->symbol (apply concat-strings sym-strings))))
#+end_src

*** emit.l

x86-32 compiler

#+begin_src lisp :noweb yes :mkdirp yes :tangle src/emit.l
(require "osdefs.k")

(define __PREFIX__ (if (or (defined? '__MACH__) (defined? '__WIN32__)) "_" ""))

(define-function string->type-name (str) (string->symbol (concat-string "<" (concat-string str ">"))))
(define-function symbol->type-name (sym) (string->type-name (symbol->string sym)))

(define-function align (alignment value)	(& (- alignment) (+ (- alignment 1) value )))

(define-function variable (name value env index)
  (let ((self (new <variable>)))
    (set (<variable>-name  self) name)
    (set (<variable>-value self) value)
    (set (<variable>-env   self) env)
    (set (<variable>-index self) index)
    self))

(define-function variable? (obj) (= <variable> (type-of obj)))

(define-function environment (parent)
  (let ((self (new <env>)))
    (set (<env>-parent   self) parent)
    (set (<env>-level    self) (if parent (<env>-level  parent) 0))
    (set (<env>-offset   self) 0)
    (set (<env>-bindings self) (array))
    self))

;;; EXTERN

(define-structure <extern> (name stub))

(define-function extern (name)
  (let ((self (new <extern>)))
    (set (<extern>-name self) name)
    self))

(define-function extern? (obj) (= <extern> (type-of obj)))

;;; DEFINE-OPERAND

(define-function define-operand-make-setters (tname fields)
  (if (pair? fields)
      (cons `(set (,(concat-symbol (concat-symbol tname '-) (car fields)) self) ,(car fields))
	    (define-operand-make-setters tname (cdr fields)))))

(define-form define-operand (name fields . printing)
  (let* ((sname (symbol->string name))
	 (tname (string->symbol (concat-string "<" (concat-string sname ">")))))
    (eval `(define-structure ,tname ,fields))
    (eval `(define-function ,name ,fields
	     (let ((self (new ,tname)))
	       ,@(define-operand-make-setters tname fields)
	       self)))
    `(define-method do-print ,tname () (print ,@printing))))

;;; DEFINE-INSTRUCTION

(define-form define-instruction (name)
  (let* ((sname (symbol->string name))
	 (tname (string->symbol (concat-string "<" (concat-string sname ">")))))
    `(let ()
       (define-structure ,tname ())
       (define-method do-print ,tname () (print ,sname))
       (define ,name (new ,tname)))))

;;; DEFINE-EMIT

(define-generic emit op-args
  (print "\nemit: illegal instruction: "op-args)
  (error "aborted"))

(define-multimethod emit ((<pair> program))
  (while program
    (apply emit (car program))
    (set program (cdr program))))

(define-function %define-emit-param-name (index)
  (string->symbol (concat-string "$" (long->string index))))

(define-function %define-emit-params (index types)
  (if (pair? types)
      (cons (list (symbol->type-name (car types)) (%define-emit-param-name index))
	    (%define-emit-params (+ index 1) (cdr types)))))

(define-form define-emit (op-args . body)
  (let* ((opsym (car op-args))
	 (sname (symbol->string opsym))
	 (tname (string->type-name sname)))
    `(let ()
       ,@(if (not (defined? opsym *globals*)) `((define-instruction ,opsym)))
       (define-multimethod emit ((,tname op) ,@(%define-emit-params 1 (cdr op-args))) ,@body))))

(define-function digit-for (c)
  (if (< c 10)
      (+ c 0x30)
    (+ c 0x37)))

(define-function mangle-label (name)
  (let* ((plain  (symbol->string name))
	 (mangled (array))
	 (index   0)
	 (outdex  0)
	 (size    (string-length plain)))
    (while (< index size)
      (let ((c (string-at plain index)))
	(cond
	  ((or (and (<= 0x61 c) (<= c 0x7a))
	       (and (<= 0x41 c) (<= c 0x5a))
	       (and (<= 0x30 c) (<= c 0x39)))	(let ()
						  (set-array-at mangled outdex c)			(set outdex (+ outdex 1))))
	  ((= ?_ c)				(let ()
						  (set-array-at mangled outdex c)			(set outdex (+ outdex 1))
						  (set-array-at mangled outdex c)			(set outdex (+ outdex 1))))
	  (else					(let ()
						  (set-array-at mangled outdex 0x5f)			(set outdex (+ outdex 1))
						  (set-array-at mangled outdex (digit-for (>> c  4)))	(set outdex (+ outdex 1))
						  (set-array-at mangled outdex (digit-for (&  c 15)))	(set outdex (+ outdex 1))))))
      (set index (+ 1 index)))
    (array->string mangled)))

;;; IA32 -- OPERANDS

(define *label-source* ())
(define *label-counter* 0)

(define-function temp-label-name ()
  (let ((label (concat-string "_L_" (long->string (set *label-counter* (+ *label-counter* 1))))))
    (and *label-source* (set label (concat-strings label"_"(car *label-source*)"_"(long->string (cdr *label-source*)))))
    label))

(define-operand LABEL (name) 	__PREFIX__(mangle-label (<LABEL>-name self)))
(define-operand GI32 (name)	(<GI32>-name self))
(define-operand LI32 (value)	(<LI32>-value self))
(define-operand TI32 (offset)	(<TI32>-offset self)"(%esp)")

(define-function temp? (obj)	(= <TI32> (type-of obj)))

;;; IA32 -- INSTRUCTIONS

(define-emit	(TEXT)			(println "	.text"))
(define-emit	(DATA)			(println "	.data"))
(define-emit	(SECTION string)	(println "	.section "$1))

(define-emit	(INDIRECT LABEL)	(println "	.indirect_symbol "$1))
(define-emit	(GLOBAL LABEL)		(println "	.globl "$1))

(define-emit	(ALIGN long)		(println "	.align " $1))

(define-emit	(LONG long)		(println "	.long "$1))
(define-emit	(LONG LABEL)		(println "	.long "$1))

(define-emit	(ASCIZ string)		(print   "	.asciz ") (dumpln $1))

(define-emit	(DEFLABEL LABEL)	(println $1":"))

(define-emit	(ENTER long)		(println "	pushl %ebp")
					(println "	movl %esp,%ebp")
					(println "	subl $"$1",%esp"))

(define-emit	(LEAVE long)		(println "	addl $"$1",%esp")
					(println "	leave")
					(println "	ret"))

(define-emit	(NEG)			(println "	negl %eax"))

(define-emit	(ADD TI32)		(println "	addl "$1",%eax"))

(define-emit	(SUB TI32)		(println "	subl "$1",%eax"))

(define-emit	(MUL TI32)		(println "	mull "$1))

(define-emit	(DIV TI32)		(println "	movl $0,%edx")
					(println "	divl "$1))

(define-emit	(AND TI32)		(println "	andl "$1",%eax"))

(define-emit	(OR TI32)		(println "	orl "$1",%eax"))

(define-emit	(XOR TI32)		(println "	xorl "$1",%eax"))

(define-emit	(NOT)			(println "	cmpl $0,%eax")
					(println "	sete %al")
					(println "	movzbl %al,%eax"))

(define-emit	(LT TI32)		(println "	cmpl "$1",%eax")
					(println "	setl %al")
					(println "	movzbl %al,%eax"))

(define-emit	(LE TI32)		(println "	cmpl "$1",%eax")
					(println "	setle %al")
					(println "	movzbl %al,%eax"))

(define-emit	(EQ TI32)		(println "	cmpl "$1",%eax")
					(println "	sete %al")
					(println "	movzbl %al,%eax"))

(define-emit	(NE TI32)		(println "	cmpl "$1",%eax")
					(println "	setne %al")
					(println "	movzbl %al,%eax"))

(define-emit	(GE TI32)		(println "	cmpl "$1",%eax")
					(println "	setge %al")
					(println "	movzbl %al,%eax"))

(define-emit	(GT TI32)		(println "	cmpl "$1",%eax")
					(println "	setg %al")
					(println "	movzbl %al,%eax"))

(define-emit	(SLA TI32)		(println "	movl "$1",%ecx")
					(println "	shll %cl,%eax"))

(define-emit	(SRA TI32)		(println "	movl "$1",%ecx")
					(println "	sarl %cl,%eax"))

(define-emit	(BR LABEL)		(println "	jmp "$1))

(define-emit	(BF LABEL)		(println "	cmpl $0,%eax")
					(println "	je "$1))

(define-emit	(BT LABEL)		(println "	cmpl $0,%eax")
					(println "	jne "$1))

(define-emit	(CALL LABEL)		(println "	call "$1))
(define-emit	(CALL long)		(println "	call *%eax"))

(define-emit	(LOAD LI32)		(println "	movl $"$1",%eax"))
(define-emit	(LOAD LABEL)		(println "	movl $"$1",%eax"))
(define-emit	(LOAD GI32)		(println "	movl " $1",%eax"))
(define-emit	(LOAD TI32)		(println "	movl " $1",%eax"))

(define-emit	(STORE TI32)		(println "	movl %eax,"$1))
(define-emit	(STORE GI32)		(println "	movl %eax,"$1))

(define-emit	(ADDR GI32)		(println "	movl $"$1",%eax"))
(define-emit	(ADDR TI32)		(println "	leal "$1",%eax"))

(define-emit	(MOVE TI32 TI32)	(println "	movl "$1",%ecx")
					(println "	movl %ecx,"$2))

(define-emit	(COMMENT pair)		(print "## ") (apply println $1))

(define-emit	(CHR-AT TI32)		(println "	movl "$1",%ecx")
					(println "	leal (%eax,%ecx),%ecx")
					(println "	xorl %eax,%eax")
					(println "	movb (%ecx),%al"))

(define-emit	(SET-CHR-AT TI32 TI32)	(println "	movl "$1",%ecx")
					(println "	leal (%eax,%ecx),%ecx")
					(println "	movl "$2",%eax")
					(println "	movb %al,(%ecx)"))

(define-emit	(OOP-AT TI32)		(println "	movl "$1",%ecx")
			  		(println "	leal (%eax,%ecx,4),%ecx")
			  		(println "	movl (%ecx),%eax"))

(define-emit	(SET-OOP-AT TI32 TI32)	(println "	movl "$1",%ecx")
					(println "	leal (%eax,%ecx,4),%ecx")
					(println "	movl "$2",%eax")
					(println "	movl %eax,(%ecx)"))

;;; 

(define-structure <compiler> (level param-counter arg-counter arg-limit tmp-counter tmp-limit temps epilogue asm pc section))

(define-function compiler (level)
  (let ((self (new <compiler>)))
    (set (<compiler>-level	   self) level)
    (set (<compiler>-param-counter self) 0)
    (set (<compiler>-arg-counter   self) 0)
    (set (<compiler>-arg-limit	   self) 0)
    (set (<compiler>-tmp-counter   self) 0)
    (set (<compiler>-tmp-limit	   self) 0)
    (set (<compiler>-asm	   self) (array))
    (set (<compiler>-pc		   self) 0)
    self))

(define-function new-param (comp)
  (let* ((i (<compiler>-param-counter comp))
	 (t (TI32 i)))
    (set (<compiler>-param-counter comp) (+ i 4))
    t))

(define-function new-arg (comp)
  (let* ((i (<compiler>-arg-counter comp))
	 (t (TI32 i)))
    (set (<compiler>-arg-counter comp) (+ i 4))
    t))

(define-function free-args (comp args)
  (and (< (<compiler>-arg-limit comp) (<compiler>-arg-counter comp))
       (set (<compiler>-arg-limit comp) (<compiler>-arg-counter comp)))
  (set (<compiler>-arg-counter comp) 0))

(define-function new-temp (comp)
  (let* ((i (<compiler>-tmp-counter comp))
	 (t (TI32 i)))
    (set (<compiler>-tmp-counter comp) (+ i 4))
    (and (< (<compiler>-tmp-limit comp) (<compiler>-tmp-counter comp))
	 (set (<compiler>-tmp-limit comp) (<compiler>-tmp-counter comp)))
    t))

(define-function alloc-temp (comp)
  (or (pop (<compiler>-temps comp))
      (new-temp comp)))

(define-function free-temp (comp temp)		(push (<compiler>-temps comp) temp))
(define-function free-temps (comp temps)	(list-do temp temps (free-temp comp temp)))

;;; GEN

(define-selector gen)

(define-method gen <compiler> args
  ;;(print "## insn ") (dumpln args)
  (set-array-at (<compiler>-asm self) (<compiler>-pc self) args)
  (set (<compiler>-pc self) (+ 1 (<compiler>-pc self))))

(define-method gen <undefined>	(comp)	(gen comp LOAD (LI32 0)))
(define-method gen <long>	(comp)	(gen comp LOAD (LI32 self)))

(define-method gen <variable> (comp)
  (let ((value (<variable>-value self)))
    (if (extern? value)
	(gen comp LOAD (GI32 (LABEL (concat-symbol (<variable>-name self) '$stub))))
      (if (temp? value)
	  (gen comp LOAD value)
	  (gen comp LOAD (GI32 (LABEL (<variable>-name self))))))))

(define-method gen <string> (comp)
  (let ((label (LABEL (temp-label-name))))
    (gen comp DATA)
    (gen comp DEFLABEL label)
    (gen comp ASCIZ self)
    (gen comp TEXT)
    (gen comp LOAD label)))

(define-function gen-tmp-prog (prog comp)
  (while (pair? prog)
    (gen (car prog) comp)
    (set prog (cdr prog)))
  (let ((t (alloc-temp comp)))
    (gen comp STORE t)
    t))

(define-function gen-tmp (expr comp)
  (gen expr comp)
  (let ((t (alloc-temp comp)))
    (gen comp STORE t)
    t))

(define-function gen-arg (expr comp)
  (new-arg comp))

(define-function gen-move (a b comp)
  (gen comp MOVE a b))

(define-function generate-nullary (op args comp)
  (gen comp op))

(define-function generate-unary (op args comp)
  (gen (car args) comp)
  (gen comp op))

(define-function generate-binary (op args comp)
  (let ((tmp (gen-tmp (cadr args) comp)))
    (gen (car args) comp)
    (free-temp comp tmp)
    (gen comp op tmp)))

(define-function generate-ternary (op args comp)
  (let ((tmp2 (gen-tmp (caddr args) comp))
	(tmp1 (gen-tmp (cadr  args) comp)))
    (gen (car args) comp)
    (free-temp comp tmp1)
    (free-temp comp tmp2)
    (gen comp op tmp1 tmp2)))

(define generators (list->array (list generate-nullary generate-unary generate-binary generate-ternary)))

(define operators (list->array
  `(()								; nullary
    ((,-  ,NEG) (,not ,NOT))					; unary
    ((,+  ,ADD) (,-   ,SUB) (,* ,MUL) (,/ ,DIV)			; binary
     (,&  ,AND) (,|   ,OR ) (,^ ,XOR)
     (,<  ,LT ) (,<=  ,LE)  (,= ,EQ ) (,!= ,NE ) (,>= ,GE ) (,> ,GT )
     (,<< ,SLA) (,>>  ,SRA)
     (,oop-at         ,OOP-AT) (,string-at         ,CHR-AT))
    ((,set-oop-at ,SET-OOP-AT) (,set-string-at ,SET-CHR-AT))	; ternary
    )))

(define-function gen-let-binding (binding comp)
  (let ((var (car binding))
	(tmp (gen-tmp-prog (cdr binding) comp)))
    (set (<variable>-value var) tmp)))

(define-function gen-let (expr comp)
  (let ((temps (map-with gen-let-binding (caddr expr) comp)))
    (list-do stmt (cdddr expr) (gen stmt comp))
    (list-do temp temps (free-temp comp temp))))

(define-function gen-and (expr comp)
  (let ((done (LABEL (temp-label-name))))
    (set expr (cdr expr))
    (while expr
      (gen (car expr) comp)
      (and (set expr (cdr expr)) (gen comp BF done)))
    (gen comp DEFLABEL done)))

(define-function gen-or (expr comp)
  (let ((done (LABEL (temp-label-name))))
    (set expr (cdr expr))
    (while expr
      (gen (car expr) comp)
      (and (set expr (cdr expr)) (gen comp BT done)))
    (gen comp DEFLABEL done)))

(define-function gen-if (expr comp)
  (let ((a (LABEL (temp-label-name)))
	(b (LABEL (temp-label-name))))
    (gen (cadr expr) comp)
    (gen comp BF a)
    (gen (caddr expr) comp)
    (gen comp BR b)
    (gen comp DEFLABEL a)
    (list-do stmt (cdddr expr) (gen stmt comp))
    (gen comp DEFLABEL b)))

(define-function gen-while (expr comp)
  (let ((body (LABEL (temp-label-name)))
	(test (LABEL (temp-label-name))))
    (gen comp BR test)
    (gen comp DEFLABEL body)
    (list-do stmt (cddr expr) (gen stmt comp))
    (gen comp DEFLABEL test)
    (gen (cadr expr) comp)
    (gen comp BT body)))

(define-function gen-set (expr comp)
  (let* ((var (cadr expr))
	 (val (<variable>-value var)))
    (gen (caddr expr) comp)
    (if (temp? val)
	(gen comp STORE val)
      (gen comp STORE (GI32 (LABEL (<variable>-name var)))))))

(define-function gen-return (expr comp)
  (list-do stmt (cdr expr) (gen stmt comp))
  (gen comp BR (or (<compiler>-epilogue comp) (set (<compiler>-epilogue comp) (LABEL (temp-label-name))))))

(define-function gen-address-of (expr comp)
  (let ((var (cadr expr)))
    (or (variable? var) (error "address-of: non-variable argument: "var))
    (let ((val (<variable>-value var)))
      (if (temp? val)
	  (gen comp ADDR val)
	(gen comp ADDR (GI32 (LABEL (<variable>-name var))))))))

(define return		(fixed (lambda args (error "(return) encountered in interpreted code"))))
(define address-of	(fixed (lambda args (error "(address-of) encountered in interpreted code"))))

(define forms (list
  (cons  let		gen-let)
  (cons  and	 	gen-and)
  (cons  or	 	gen-or)
  (cons  if	 	gen-if)
  (cons  while		gen-while)
  (cons  set	 	gen-set)
  (cons  return		gen-return)
  (cons  address-of	gen-address-of)))

(define-method gen <pair> (comp)
  (and (= 0 (optimised))
       (let ((source (oop-at self 2)))
	 (and (!= *label-source* source)
	      (car source)
	      (let ()
		(set *label-source* source)
		;;(gen comp DEFLABEL (LABEL (temp-label-name)))		;; DEBUG ONLY
		;;(gen comp COMMENT (list (car source) " " (cdr source)))
		(gen comp DEFLABEL (LABEL (temp-label-name)))))))
  (let* ((head  (car self))
	 (arity (- (list-length self) 1))
	 (op    (and (variable? head) (cadr (assq (<variable>-value head) (array-at operators arity))))))
    (if op
	((array-at generators arity) op (cdr self) comp)
      (if (set op (cdr (assq head forms)))
	  (op self comp)
	(let* ((tmps (map-with gen-tmp (cdr self) comp))
	       (args (map-with gen-arg (cdr self) comp))
	       (func (gen (car self) comp))
	       (narg (list-length args)))
	  (map2-with gen-move tmps args comp)
	  (free-temps comp tmps)
	  (free-args  comp args)
	  (gen comp CALL narg))))))

;;; GEN-DEFINITION

(define-selector gen-definition)

(define-method gen-definition <long> (name comp)
  (gen comp DATA)
  (gen comp DEFLABEL (LABEL name))
  (gen comp LONG self)
  (gen comp TEXT))

(define-method gen-definition <string> (name comp)
  (let ((temp (LABEL (temp-label-name))))
    (gen comp DATA)
    (gen comp DEFLABEL temp)
    (gen comp ASCIZ self)
    (gen comp ALIGN 4)
    (gen comp DEFLABEL (LABEL name))
    (gen comp LONG temp)
    (gen comp TEXT)))

(define-method gen-definition <extern> (name comp)
  (let ((nlabel (LABEL                self.name        ))
	(slabel (LABEL (concat-symbol self.name '$stub))))
    (if (defined? '__MACH__)
	(let ()
	  (gen comp SECTION "__IMPORT,__pointers,non_lazy_symbol_pointers")
	  (gen comp DEFLABEL slabel)
	  (gen comp INDIRECT nlabel)
	  (gen comp LONG 0)
	  (gen comp TEXT))
      (gen comp DATA)
      (gen comp DEFLABEL slabel)
      (gen comp LONG nlabel)
      (gen comp TEXT))))

(define-method gen-definition <form> (name comp)
  (gen comp COMMENT (list "form "name)))

(define-function gen-param (var comp)
  ;;(print "gen-param ") (dumpln var)
  (set (<variable>-value var) (new-param comp)))

(define-method gen-definition <expr> (name ocomp)
  (let* ((main (= 'main name))
	 (defn (<expr>-defn self))
	 (body (cddr defn))
	 (comp (compiler (+ 1 (<compiler>-level ocomp))))
	 (tnam (if main (LABEL name) (LABEL (temp-label-name))))
	 (vnam (if main ()           (LABEL name)))
	 (params (map-with gen-param (cadr defn) comp)))
    (list-do e body (gen e comp))
    (let* ((arg-size (align 16             (<compiler>-arg-limit comp) ))
	   (tmp-size (align 16 (+ arg-size (<compiler>-tmp-limit comp))))
	   (frm-size (align 16 (+ tmp-size 8))))
      (map (lambda (tmp) (set (<TI32>-offset tmp) (+ arg-size (<TI32>-offset tmp)))) (<compiler>-temps comp))
      (map (lambda (tmp) (set (<TI32>-offset tmp) (+ frm-size (<TI32>-offset tmp)))) params)
      (emit TEXT)
      (and main (emit GLOBAL tnam))
      (emit DEFLABEL tnam)
      (emit COMMENT (list "frame "arg-size" "(<compiler>-tmp-limit comp)" "tmp-size" "frm-size))
      (emit ENTER (- frm-size 8))
      (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i)))
      (and (<compiler>-epilogue comp)
	   (emit DEFLABEL (<compiler>-epilogue comp)))
      (emit LEAVE (- frm-size 8)))
    (or main
      (let ()
	(gen ocomp DATA)
	(gen ocomp GLOBAL vnam)
	(gen ocomp DEFLABEL vnam)
	(gen ocomp LONG tnam)
	(gen ocomp TEXT)))))

;;; 

(define-function gen-env (env)
  (let* ((vars  (<env>-bindings env))
	 (comp  (compiler 0))
	 (index (array-length vars)))
    (while (<= 0 (set index (- index 1)))
      (let ((name  (<variable>-name  (array-at vars index)))
	    (value (<variable>-value (array-at vars index))))
	(println "## defn " name)
	(warn name "\n")
	;;x;(println (<expr>-defn (cdar env)))
	(gen-definition value name comp)))
    (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i)))))

(define-form compile-begin ()	`(set *globals* (environment *globals*)))

(define-form compile-end ()	(let ((env *globals*))
				  (set *globals* (<env>-parent env))
				  (gen-env env)))
#+end_src

*** bootstrap/mkosdefs.c

#+begin_src c :noweb yes :mkdirp yes :tangle src/bootstrap/mkosdefs.c
#include <stdio.h>

#define STR(X)		#X

#define defint(X)	printf("(define %s %d)\n", #X, X)
#define defstr(X)	printf("(define %s \"%s\")\n", #X, STR(X))

int main()
{
# ifdef __APPLE__
    defint(__APPLE__);
# endif
# ifdef __ELF__
    defint(__ELF__);
# endif
# ifdef __LITTLE_ENDIAN__
    defint(__LITTLE_ENDIAN__);
# endif
# ifdef __MACH__
    defint(__MACH__);
# endif
# ifdef __WIN32__
    defint(__WIN32__);
# endif
# ifdef __USER_LABEL_PREFIX__
    defstr(__USER_LABEL_PREFIX__);
# endif
# ifdef __i386__
    defint(__i386__);
# endif
# ifdef __i586__
    defint(__i586__);
# endif
# ifdef __linux__
    defint(__linux__);
# endif
    return 0;
}
#+end_src